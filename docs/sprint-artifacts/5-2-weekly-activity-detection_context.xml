<?xml version="1.0" encoding="UTF-8"?>
<story-context>
  <story-id>5-2-weekly-activity-detection</story-id>
  <epic>Epic 5: Scheduled Jobs & Weekly Reviews</epic>
  <generated-at>2025-11-24T12:00:00Z</generated-at>

  <summary>
    Activity detection service that identifies users with activity in the past 7 days for weekly review job.
    Activity is defined as either:
    - Transactions created in the last 7 days, OR
    - Bot interactions (last_activity_at) within 7 days

    Excludes dormant users and users who opted out of re-engagement messages.
    Used by Story 5.3 (Weekly Review Job) to determine celebratory message recipients.
  </summary>

  <acceptance-criteria>
    <criterion id="AC-5.2.1">
      Given getActiveUsersLastWeek() is called, when executed, then it returns users who have either transactions created in the last 7 days OR last_activity_at within 7 days.
    </criterion>
    <criterion id="AC-5.2.2">
      Given a user has state = 'dormant', when getActiveUsersLastWeek() runs, then that user is excluded.
    </criterion>
    <criterion id="AC-5.2.3">
      Given a user has reengagement_opt_out = true, when getActiveUsersLastWeek() runs, then that user is excluded.
    </criterion>
  </acceptance-criteria>

  <dependencies>
    <epic-dependency>
      <epic>Epic 1: Foundation & Message Infrastructure</epic>
      <reason>Uses database schema from migration 034_engagement_system.sql</reason>
      <files>
        <file>fe/scripts/034_engagement_system.sql</file>
      </files>
    </epic-dependency>

    <epic-dependency>
      <epic>Epic 4: Engagement State Machine</epic>
      <reason>Reads user_engagement_states table for state filtering and last_activity_at</reason>
      <files>
        <file>whatsapp-bot/src/services/engagement/state-machine.ts</file>
      </files>
    </epic-dependency>

    <story-dependency>
      <story>1.1 Database Schema Migration</story>
      <reason>Requires user_engagement_states, user_profiles, and transactions tables with indexes</reason>
    </story-dependency>

    <story-dependency>
      <story>4.2 Activity Tracking & Auto-Reactivation</story>
      <reason>Relies on last_activity_at being updated on every user message/action</reason>
    </story-dependency>

    <story-dependency>
      <story>5.3 Weekly Review Job & Message</story>
      <reason>This service is consumed by the weekly review job to identify active users</reason>
    </story-dependency>
  </dependencies>

  <technical-context>
    <architecture>
      <pattern name="Database Function Pattern">
        Use a PostgreSQL function (get_active_users_last_week) to perform the complex query with joins and aggregations.
        This minimizes data transfer, leverages database optimization, and reduces N+1 query risk.
        TypeScript service calls the RPC function and maps results to ActiveUser interface.
      </pattern>

      <pattern name="Activity Dual-Source Detection">
        Users are "active" if they:
        1. Created transactions in last 7 days (explicit expense tracking), OR
        2. Had bot interactions via last_activity_at (engagement without transactions)

        This ensures users who engage with the bot but don't log expenses still receive celebration.
      </pattern>

      <pattern name="Exclusion Filters">
        Filter at query level (WHERE clause), not per-user iteration:
        - state IN ('active', 'help_flow') — excludes dormant (AC-5.2.2)
        - reengagement_opt_out = false — excludes opted-out (AC-5.2.3)
        - Activity condition: (has transactions OR has bot activity)
      </pattern>

      <pattern name="Performance Optimization">
        Single aggregated query with:
        - LEFT JOIN transactions (captures users with/without transactions)
        - GROUP BY for transaction count aggregation
        - Indexed columns for fast filtering
        Target: &lt; 5 seconds for 10,000 users
      </pattern>
    </architecture>

    <database>
      <table name="user_engagement_states">
        <schema>
          <column name="user_id" type="UUID" indexed="true" unique="true"/>
          <column name="state" type="TEXT" indexed="true" values="active|goodbye_sent|help_flow|remind_later|dormant"/>
          <column name="last_activity_at" type="TIMESTAMPTZ" indexed="true" note="Updated on every user message/action"/>
        </schema>

        <indexes>
          <index name="idx_engagement_state" columns="state" note="For state filtering"/>
          <index name="idx_engagement_last_activity" columns="last_activity_at" note="For 7-day lookback"/>
        </indexes>

        <usage-note>
          last_activity_at tracks bot interactions (messages sent to bot, command executions).
          This complements transaction data to detect users who engage without logging expenses.
        </usage-note>
      </table>

      <table name="user_profiles">
        <schema>
          <column name="user_id" type="UUID" indexed="true" primary="true"/>
          <column name="reengagement_opt_out" type="BOOLEAN" default="false" note="AC-5.2.3: Skip opted-out users"/>
          <column name="preferred_destination" type="TEXT" default="individual" values="individual|group"/>
          <column name="whatsapp_jid" type="TEXT" note="Destination for weekly review messages"/>
          <column name="locale" type="TEXT" default="pt-BR" note="Message localization"/>
        </schema>

        <usage-note>
          preferred_destination and whatsapp_jid are needed for Story 5.3 to queue messages.
          locale determines message language.
        </usage-note>
      </table>

      <table name="transactions">
        <schema>
          <column name="id" type="UUID" primary="true"/>
          <column name="user_id" type="UUID" indexed="true"/>
          <column name="created_at" type="TIMESTAMPTZ" indexed="true" note="Check for activity in last 7 days"/>
          <column name="amount" type="NUMERIC"/>
          <column name="description" type="TEXT"/>
        </schema>

        <indexes>
          <index name="idx_transactions_created_at" columns="created_at" note="For date range queries"/>
          <index name="idx_transactions_user_id" columns="user_id" note="For user-specific queries"/>
          <index name="idx_transactions_user_created" columns="user_id, created_at" note="Composite for weekly query"/>
        </indexes>

        <usage-note>
          Transaction creation indicates explicit expense tracking activity.
          Used to count how many expenses user logged in past 7 days.
        </usage-note>
      </table>

      <database-function name="get_active_users_last_week">
        <signature>
          CREATE OR REPLACE FUNCTION get_active_users_last_week(since_date TIMESTAMPTZ)
          RETURNS TABLE (
            user_id UUID,
            transaction_count BIGINT,
            last_activity_at TIMESTAMPTZ,
            preferred_destination TEXT,
            destination_jid TEXT,
            locale TEXT
          )
        </signature>

        <implementation>
          -- Query Logic:
          -- 1. Start with user_profiles (base table)
          -- 2. JOIN user_engagement_states for state + last_activity_at
          -- 3. LEFT JOIN transactions for transaction counts
          -- 4. Filter by:
          --    - state IN ('active', 'help_flow') [exclude dormant]
          --    - reengagement_opt_out = false [exclude opted-out]
          --    - (has transactions OR has bot activity in 7 days)
          -- 5. GROUP BY user to aggregate transaction counts
          -- 6. Return all needed fields for weekly review job
        </implementation>

        <query-optimization>
          - Uses indexed columns in WHERE clause
          - LEFT JOIN allows users with no transactions
          - GROUP BY aggregates counts in single pass
          - DISTINCT ensures one row per user
          - Returns only necessary columns
        </query-optimization>

        <performance-target>
          &lt; 5 seconds for 10,000 users with 100,000 transactions
        </performance-target>
      </database-function>
    </database>

    <service-contracts>
      <interface name="ActiveUser">
        <typescript><![CDATA[
export interface ActiveUser {
  userId: string
  transactionCount: number  // Transactions in last 7 days
  lastActivityAt: Date      // Most recent bot interaction
  preferredDestination: 'individual' | 'group'
  destinationJid: string    // WhatsApp JID for message delivery
  locale: string            // User's locale (pt-BR or en)
}
        ]]></typescript>

        <usage-note>
          Returned by getActiveUsersLastWeek(), consumed by Weekly Review Job (Story 5.3).
          Contains all info needed to queue a weekly review message.
        </usage-note>
      </interface>

      <function name="getActiveUsersLastWeek">
        <signature>
          export async function getActiveUsersLastWeek(): Promise&lt;ActiveUser[]&gt;
        </signature>

        <description>
          Get users with activity in the last 7 days.

          Activity defined as:
          - Transactions created in last 7 days, OR
          - Bot interactions (last_activity_at) in last 7 days

          Excludes:
          - Dormant users (state = 'dormant') [AC-5.2.2]
          - Opted-out users (reengagement_opt_out = true) [AC-5.2.3]
        </description>

        <implementation-steps>
          1. Calculate 7 days ago date
          2. Call Supabase RPC: get_active_users_last_week(since_date)
          3. Handle database errors gracefully
          4. Map database rows to ActiveUser interface
          5. Log result count for observability
          6. Return array of active users
        </implementation-steps>

        <error-handling>
          - Database errors: Log and throw (job should fail fast)
          - Empty results: Return empty array (not an error)
          - Malformed rows: Log warning, skip invalid rows
        </error-handling>
      </function>

      <function name="getUserActivityCount">
        <signature>
          export async function getUserActivityCount(
            userId: string,
            days: number
          ): Promise&lt;number&gt;
        </signature>

        <description>
          Get activity count for a specific user over a time period.
          Used for analytics, debugging, and testing.

          Counts:
          - Number of transactions in period
          - Bot activity presence (0 or 1)

          Returns: Total activity count
        </description>

        <implementation-steps>
          1. Calculate since_date from days parameter
          2. Query transactions table for count (user_id, created_at &gt; since_date)
          3. Query user_engagement_states for last_activity_at
          4. Add 1 if last_activity_at &gt; since_date (bot activity present)
          5. Return total count
        </implementation-steps>

        <usage-note>
          This is a helper function for testing and analytics.
          Not used by weekly review job (which uses getActiveUsersLastWeek).
        </usage-note>
      </function>
    </service-contracts>

    <supabase-client>
      <service-path>whatsapp-bot/src/services/database/supabase-client.ts</service-path>

      <usage-pattern><![CDATA[
import { getSupabaseClient } from '../database/supabase-client.js'

const supabase = getSupabaseClient()  // Singleton with SUPABASE_SERVICE_KEY

// RPC call to database function
const { data, error } = await supabase.rpc('get_active_users_last_week', {
  since_date: sevenDaysAgo.toISOString()
})

if (error) {
  logger.error('Failed to get active users', { error })
  throw error
}
      ]]></usage-pattern>

      <client-features>
        - Uses SUPABASE_SERVICE_KEY for full database access
        - Bypasses Row Level Security (RLS) policies
        - Singleton pattern for connection reuse
        - Configured for server-side operations (no session persistence)
      </client-features>
    </supabase-client>

    <logging>
      <service-path>whatsapp-bot/src/services/monitoring/logger.ts</service-path>

      <pattern name="Structured Logging">
        <description>
          Use structured logging with context objects for filtering and debugging.
          Logger supports: debug, info, warn, error levels.
        </description>

        <example type="function-entry"><![CDATA[
logger.info('Detecting active users for weekly review', {
  since_date: sevenDaysAgo.toISOString(),
  lookback_days: 7
})
        ]]></example>

        <example type="success"><![CDATA[
logger.info('Active users detected', {
  count: activeUsers.length,
  since: sevenDaysAgo.toISOString(),
  duration_ms: Date.now() - startTime
})
        ]]></example>

        <example type="error"><![CDATA[
logger.error('Failed to get active users', {
  since_date: sevenDaysAgo.toISOString(),
  error: error.message
})
        ]]></example>

        <example type="debug"><![CDATA[
logger.debug('User activity count', {
  userId,
  days,
  transactionCount,
  botActivityCount,
  totalCount
})
        ]]></example>
      </pattern>

      <log-context-fields>
        - since_date: ISO timestamp of lookback start
        - count: Number of active users found
        - duration_ms: Query execution time
        - userId: Specific user ID for debugging
        - transactionCount: Number of transactions
        - botActivityCount: Bot interaction presence (0 or 1)
        - error: Error message/object
      </log-context-fields>
    </logging>
  </technical-context>

  <implementation-patterns>
    <pattern name="Database Function + TypeScript Wrapper">
      <description>
        Complex queries are implemented as PostgreSQL functions.
        TypeScript service is a thin wrapper that:
        1. Calls RPC function
        2. Maps results to TypeScript interfaces
        3. Handles errors
        4. Logs execution
      </description>

      <benefits>
        - Database optimizations (indexes, query planner)
        - Minimal data transfer over network
        - Type safety at application boundary
        - Testable without real database (mock RPC call)
      </benefits>

      <code-example><![CDATA[
// TypeScript service (activity-detector.ts)
export async function getActiveUsersLastWeek(): Promise<ActiveUser[]> {
  const sevenDaysAgo = new Date()
  sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7)

  const supabase = getSupabaseClient()
  const { data, error } = await supabase.rpc('get_active_users_last_week', {
    since_date: sevenDaysAgo.toISOString()
  })

  if (error) throw error

  return (data || []).map(row => ({
    userId: row.user_id,
    transactionCount: row.transaction_count,
    lastActivityAt: new Date(row.last_activity_at),
    preferredDestination: row.preferred_destination,
    destinationJid: row.destination_jid,
    locale: row.locale
  }))
}
      ]]></code-example>
    </pattern>

    <pattern name="Activity Detection Logic">
      <description>
        User is "active" if either condition is true:
        1. Has transactions in last 7 days (explicit tracking)
        2. Has bot interactions in last 7 days (engagement without tracking)

        SQL: WHERE (t.id IS NOT NULL OR ues.last_activity_at > since_date)
      </description>

      <rationale>
        Some users engage with bot but don't log expenses yet.
        They should still receive weekly celebration for engagement.
        Both types of activity demonstrate active usage.
      </rationale>
    </pattern>

    <pattern name="Exclusion Filters in Query">
      <description>
        Filters are applied in SQL WHERE clause, not in TypeScript iteration.
        This reduces data transfer and leverages database indexes.
      </description>

      <filters>
        - state IN ('active', 'help_flow'): Exclude dormant users (AC-5.2.2)
        - reengagement_opt_out = false: Exclude opted-out users (AC-5.2.3)
        - Activity condition: (has transactions OR has bot activity)
      </filters>

      <anti-pattern>
        DO NOT:
        1. Query all users
        2. Filter in TypeScript loop
        3. Check opt-out per-user

        This causes N+1 queries and poor performance.
      </anti-pattern>
    </pattern>

    <pattern name="Single Aggregated Query">
      <description>
        Use GROUP BY to aggregate transaction counts in single query.
        Avoid separate query per user for transaction count.
      </description>

      <sql-structure><![CDATA[
SELECT
  up.user_id,
  COUNT(DISTINCT t.id) as transaction_count,  -- Aggregated
  ues.last_activity_at,
  up.preferred_destination,
  up.whatsapp_jid,
  COALESCE(up.locale, 'pt-BR') as locale
FROM user_profiles up
JOIN user_engagement_states ues ON up.user_id = ues.user_id
LEFT JOIN transactions t ON up.user_id = t.user_id AND t.created_at > since_date
WHERE
  ues.state IN ('active', 'help_flow')
  AND up.reengagement_opt_out = false
  AND (t.id IS NOT NULL OR ues.last_activity_at > since_date)
GROUP BY up.user_id, ues.last_activity_at, up.preferred_destination, up.whatsapp_jid, up.locale
      ]]></sql-structure>

      <performance>
        - Single query execution
        - Database performs aggregation efficiently
        - Indexed columns for fast filtering
        - Target: &lt; 5 seconds for 10,000 users
      </performance>
    </pattern>

    <pattern name="Error Handling Strategy">
      <description>
        Activity detection is critical for weekly job.
        Fail fast on database errors (don't return partial results).
      </description>

      <error-types>
        - Database connection failure: Throw error (job fails)
        - RPC function error: Log and throw (job fails)
        - Empty results: Return empty array (not an error)
        - Malformed data: Log warning, skip row, continue
      </error-types>

      <code-example><![CDATA[
try {
  const { data, error } = await supabase.rpc('get_active_users_last_week', params)

  if (error) {
    logger.error('Failed to get active users', { error })
    throw error  // Fail fast
  }

  const activeUsers = (data || []).map(row => {
    try {
      return mapToActiveUser(row)
    } catch (mappingError) {
      logger.warn('Skipping malformed row', { row, error: mappingError })
      return null
    }
  }).filter(Boolean)

  return activeUsers
} catch (error) {
  logger.error('Activity detection failed', { error })
  throw error  // Let job fail
}
      ]]></code-example>
    </pattern>
  </implementation-patterns>

  <edge-cases>
    <case id="1" title="User with no transactions but bot activity">
      <scenario>User sends messages to bot but hasn't logged any expenses</scenario>
      <expected-behavior>User IS included (AC-5.2.1: bot activity counts)</expected-behavior>
      <sql-condition>t.id IS NULL AND ues.last_activity_at > since_date</sql-condition>
    </case>

    <case id="2" title="User with transactions but no bot activity">
      <scenario>User logged expenses via web app, no WhatsApp messages</scenario>
      <expected-behavior>User IS included (AC-5.2.1: transactions count)</expected-behavior>
      <sql-condition>t.id IS NOT NULL (regardless of last_activity_at)</sql-condition>
    </case>

    <case id="3" title="User with activity exactly 7 days ago">
      <scenario>Last activity timestamp = exactly 7 days ago (to the second)</scenario>
      <expected-behavior>User IS excluded (query uses >, not >=)</expected-behavior>
      <implementation-note>Use strict inequality for clear 7-day window</implementation-note>
    </case>

    <case id="4" title="User in help_flow state">
      <scenario>User triggered help flow, still engaged with bot</scenario>
      <expected-behavior>User IS included (help_flow is active state)</expected-behavior>
      <sql-condition>state IN ('active', 'help_flow')</sql-condition>
    </case>

    <case id="5" title="User in goodbye_sent state">
      <scenario>User received goodbye message, awaiting response</scenario>
      <expected-behavior>User IS excluded (not in active states list)</expected-behavior>
      <rationale>User in transition, not celebrating yet</rationale>
    </case>

    <case id="6" title="User in dormant state">
      <scenario>User transitioned to dormant after inactivity</scenario>
      <expected-behavior>User IS excluded (AC-5.2.2: dormant excluded)</expected-behavior>
      <sql-condition>state IN ('active', 'help_flow') — dormant not included</sql-condition>
    </case>

    <case id="7" title="User with reengagement_opt_out = true">
      <scenario>User opted out of re-engagement messages</scenario>
      <expected-behavior>User IS excluded (AC-5.2.3: opt-out excluded)</expected-behavior>
      <sql-condition>reengagement_opt_out = false</sql-condition>
    </case>

    <case id="8" title="User with NULL locale">
      <scenario>User profile missing locale value</scenario>
      <expected-behavior>Default to 'pt-BR' (Brazilian Portuguese)</expected-behavior>
      <sql-condition>COALESCE(up.locale, 'pt-BR')</sql-condition>
    </case>

    <case id="9" title="No active users in period">
      <scenario>Query returns 0 rows (no activity last week)</scenario>
      <expected-behavior>Return empty array (not an error)</expected-behavior>
      <implementation-note>Weekly job will send 0 messages (valid scenario)</implementation-note>
    </case>

    <case id="10" title="User with multiple transactions">
      <scenario>User logged 50 transactions in last 7 days</scenario>
      <expected-behavior>transactionCount = 50, one row per user</expected-behavior>
      <sql-condition>GROUP BY ensures one row, COUNT aggregates all transactions</sql-condition>
    </case>
  </edge-cases>

  <testing-requirements>
    <test-file>whatsapp-bot/src/__tests__/scheduler/activity-detector.test.ts</test-file>

    <test-cases>
      <test id="1" ac="AC-5.2.1" priority="critical">
        <name>User with transactions in last 7 days is returned</name>
        <setup>
          Mock user:
          - state = 'active'
          - reengagement_opt_out = false
          - transactions: 3 in last 7 days
          - last_activity_at = 10 days ago
        </setup>
        <expect>User included, transactionCount = 3</expect>
      </test>

      <test id="2" ac="AC-5.2.1" priority="critical">
        <name>User with bot activity only (no transactions) is returned</name>
        <setup>
          Mock user:
          - state = 'active'
          - reengagement_opt_out = false
          - transactions: 0
          - last_activity_at = 2 days ago
        </setup>
        <expect>User included, transactionCount = 0</expect>
      </test>

      <test id="3" ac="AC-5.2.1" priority="critical">
        <name>User with both transactions and bot activity is returned</name>
        <setup>
          Mock user:
          - state = 'active'
          - reengagement_opt_out = false
          - transactions: 5 in last 7 days
          - last_activity_at = 1 day ago
        </setup>
        <expect>User included, transactionCount = 5</expect>
      </test>

      <test id="4" ac="AC-5.2.1" priority="high">
        <name>User with activity 8 days ago is excluded</name>
        <setup>
          Mock user:
          - state = 'active'
          - reengagement_opt_out = false
          - transactions: 1 at 8 days ago
          - last_activity_at = 8 days ago
        </setup>
        <expect>User excluded (no activity in 7-day window)</expect>
      </test>

      <test id="5" ac="AC-5.2.2" priority="critical">
        <name>User with state='dormant' is excluded</name>
        <setup>
          Mock user:
          - state = 'dormant'
          - reengagement_opt_out = false
          - transactions: 5 in last 7 days
          - last_activity_at = 1 day ago
        </setup>
        <expect>User excluded (dormant state excluded per AC-5.2.2)</expect>
      </test>

      <test id="6" ac="AC-5.2.3" priority="critical">
        <name>User with reengagement_opt_out=true is excluded</name>
        <setup>
          Mock user:
          - state = 'active'
          - reengagement_opt_out = true
          - transactions: 5 in last 7 days
          - last_activity_at = 1 day ago
        </setup>
        <expect>User excluded (opted out per AC-5.2.3)</expect>
      </test>

      <test id="7" ac="AC-5.2.1" priority="high">
        <name>Transaction count is accurate for multiple transactions</name>
        <setup>
          Mock user:
          - state = 'active'
          - reengagement_opt_out = false
          - transactions: 15 in last 7 days
          - last_activity_at = 2 days ago
        </setup>
        <expect>User included, transactionCount = 15</expect>
      </test>

      <test id="8" priority="medium">
        <name>Empty result when no active users</name>
        <setup>Mock database returns empty array</setup>
        <expect>Function returns empty array (no error)</expect>
      </test>

      <test id="9" priority="medium">
        <name>User in help_flow state is included</name>
        <setup>
          Mock user:
          - state = 'help_flow'
          - reengagement_opt_out = false
          - transactions: 2 in last 7 days
          - last_activity_at = 3 days ago
        </setup>
        <expect>User included (help_flow is active state)</expect>
      </test>

      <test id="10" priority="high">
        <name>Query performance (< 5s for 1000 users)</name>
        <setup>Mock 1000 users with varying activity</setup>
        <expect>Function completes in &lt; 5000ms</expect>
      </test>

      <test id="11" priority="medium">
        <name>getUserActivityCount returns correct count</name>
        <setup>
          Mock user:
          - transactions: 5 in last 7 days
          - last_activity_at = 2 days ago
        </setup>
        <expect>getUserActivityCount(userId, 7) returns 6 (5 tx + 1 bot)</expect>
      </test>

      <test id="12" priority="medium">
        <name>Database error is thrown</name>
        <setup>Mock Supabase RPC returns error</setup>
        <expect>Function throws error (fail fast)</expect>
      </test>
    </test-cases>

    <mocking-strategy>
      <mock target="getSupabaseClient">
        Return mock client with mock rpc() method.
        Mock returns { data, error } matching expected structure.
      </mock>

      <mock target="logger">
        Spy on log calls, verify correct context passed.
        Don't output to console in tests.
      </mock>

      <mock-data-structure><![CDATA[
// Mock database rows
const mockActiveUsers = [
  {
    user_id: 'user-1',
    transaction_count: 5,
    last_activity_at: '2025-11-23T10:00:00Z',
    preferred_destination: 'individual',
    destination_jid: '5511999999999@s.whatsapp.net',
    locale: 'pt-BR'
  },
  // ... more users
]

// Mock Supabase client
const mockSupabase = {
  rpc: jest.fn().mockResolvedValue({ data: mockActiveUsers, error: null })
}
      ]]></mock-data-structure>
    </mocking-strategy>

    <coverage-target>
      70% minimum for branches, functions, lines, statements
    </coverage-target>
  </testing-requirements>

  <files-to-create>
    <file path="whatsapp-bot/src/services/scheduler/activity-detector.ts">
      <description>Main activity detection service with getActiveUsersLastWeek() and getUserActivityCount() functions</description>
      <exports>
        <export name="getActiveUsersLastWeek" type="function" returns="Promise&lt;ActiveUser[]&gt;"/>
        <export name="getUserActivityCount" type="function" returns="Promise&lt;number&gt;"/>
        <export name="ActiveUser" type="interface"/>
      </exports>
      <imports>
        - getSupabaseClient from '../database/supabase-client.js'
        - logger from '../monitoring/logger.js'
      </imports>
      <implementation-notes>
        - Use supabase.rpc() to call database function
        - Map database rows to ActiveUser interface
        - Handle errors gracefully with logging
        - Return empty array on no results (not error)
      </implementation-notes>
    </file>

    <file path="fe/scripts/029_get_active_users_function.sql">
      <description>PostgreSQL function for weekly activity detection with aggregated query</description>
      <function-signature>
        CREATE OR REPLACE FUNCTION get_active_users_last_week(since_date TIMESTAMPTZ)
        RETURNS TABLE (...)
      </function-signature>
      <implementation-notes>
        - LEFT JOIN transactions for users with/without transactions
        - Filter by state, opt-out, and activity conditions
        - GROUP BY to aggregate transaction counts
        - Use indexed columns for performance
        - Return all fields needed for weekly review job
      </implementation-notes>
      <migration-order>
        Run after 028_multi_identifier_support.sql
        Before Story 5.3 implementation
      </migration-order>
    </file>

    <file path="whatsapp-bot/src/__tests__/scheduler/activity-detector.test.ts">
      <description>Unit tests for activity detection service</description>
      <framework>Jest</framework>
      <test-structure>
        - describe('getActiveUsersLastWeek')
        - describe('getUserActivityCount')
        - Mock Supabase client and logger
        - Test all acceptance criteria
        - Test edge cases
        - Test error handling
      </test-structure>
      <coverage-target>70% (branches, functions, lines, statements)</coverage-target>
    </file>
  </files-to-create>

  <critical-requirements>
    <requirement id="1" priority="critical">
      Activity detection uses TWO sources: transactions AND last_activity_at (AC-5.2.1).
      Users qualify with EITHER source, not both required.
    </requirement>

    <requirement id="2" priority="critical">
      Exclude dormant users (state = 'dormant') per AC-5.2.2.
      Include active and help_flow states only.
    </requirement>

    <requirement id="3" priority="critical">
      Exclude opted-out users (reengagement_opt_out = true) per AC-5.2.3.
      Check this in query WHERE clause, not per-user iteration.
    </requirement>

    <requirement id="4" priority="critical">
      Use database function (RPC) for query, not direct table queries.
      This ensures performance and leverages database optimization.
    </requirement>

    <requirement id="5" priority="high">
      Single aggregated query with GROUP BY for transaction counts.
      No N+1 queries (separate query per user).
    </requirement>

    <requirement id="6" priority="high">
      Performance target: &lt; 5 seconds for 10,000 users.
      Use indexed columns (state, last_activity_at, created_at).
    </requirement>

    <requirement id="7" priority="high">
      Return ALL fields needed by weekly review job:
      - userId, transactionCount, lastActivityAt
      - preferredDestination, destinationJid, locale
    </requirement>

    <requirement id="8" priority="medium">
      Default locale to 'pt-BR' if NULL (COALESCE in SQL).
    </requirement>

    <requirement id="9" priority="medium">
      Fail fast on database errors (throw, don't return partial results).
      Empty results are valid (return empty array).
    </requirement>

    <requirement id="10" priority="medium">
      Use structured logging with context (count, duration, errors).
    </requirement>
  </critical-requirements>

  <integration-notes>
    <integration-point name="Weekly Review Job (Story 5.3)">
      <description>
        Story 5.3 calls getActiveUsersLastWeek() to get list of users.
        For each user, it queues a weekly review message using fields:
        - userId, destinationJid, locale
        - transactionCount (for message personalization)
      </description>

      <data-flow>
        Weekly Review Job → getActiveUsersLastWeek() → ActiveUser[]
        → For each user: queueMessage(weekly_review)
      </data-flow>
    </integration-point>

    <integration-point name="Database Schema (Epic 1)">
      <description>
        Relies on tables and indexes from 034_engagement_system.sql:
        - user_engagement_states (state, last_activity_at)
        - user_profiles (reengagement_opt_out, preferred_destination)
        - transactions (created_at for activity detection)
      </description>

      <validation>
        Verify indexes exist before deploying:
        - idx_engagement_state
        - idx_engagement_last_activity
        - idx_transactions_user_created
      </validation>
    </integration-point>

    <integration-point name="Activity Tracking (Story 4.2)">
      <description>
        Story 4.2 updates last_activity_at on every user message.
        This ensures bot interactions are captured for weekly detection.
      </description>

      <dependency>
        Activity detector assumes last_activity_at is current.
        If Story 4.2 not complete, bot activity won't be detected.
      </dependency>
    </integration-point>
  </integration-notes>

  <performance-expectations>
    <target name="Query Execution Time">
      &lt; 5 seconds for 10,000 users with 100,000 transactions
    </target>

    <target name="Memory Usage">
      &lt; 100MB for result set (10,000 users × ~10 fields)
    </target>

    <target name="Database Load">
      Single query execution, no repeated calls
    </target>

    <optimization-techniques>
      <technique>Use database function (reduces round trips)</technique>
      <technique>Indexed WHERE clauses (state, last_activity_at, created_at)</technique>
      <technique>LEFT JOIN with GROUP BY (single aggregation pass)</technique>
      <technique>Partial indexes on date columns (faster filtering)</technique>
      <technique>Return only necessary columns (reduce data transfer)</technique>
    </optimization-techniques>

    <scaling-considerations>
      At 100,000 users:
      - Query time may approach 30-60 seconds
      - Consider pagination or incremental processing
      - Monitor database CPU/memory during execution
      - May need query optimization or caching
    </scaling-considerations>
  </performance-expectations>

  <references>
    <epic-tech-spec>docs/sprint-artifacts/tech-spec-epic-5.md</epic-tech-spec>
    <architecture-doc>docs/architecture.md (ADR-002: Database-Driven Scheduler)</architecture-doc>
    <database-migration>fe/scripts/034_engagement_system.sql</database-migration>
    <story-5-1>docs/sprint-artifacts/5-1-daily-engagement-job.md (Related scheduler story)</story-5-1>
    <story-5-3>docs/sprint-artifacts/5-3-weekly-review-job-message.md (Consumer of this service)</story-5-3>
  </references>

  <notes>
    <note type="design-decision">
      Using database function instead of TypeScript query builder for:
      - Better query optimization by PostgreSQL planner
      - Reduced data transfer (aggregation on server)
      - Easier to test query logic independently
      - Cleaner separation of concerns
    </note>

    <note type="implementation">
      Migration script (029_get_active_users_function.sql) must be run before service implementation.
      TypeScript service depends on database function existing.
    </note>

    <note type="testing">
      Mock Supabase RPC calls in tests, not real database.
      Test query logic separately via SQL integration tests if needed.
    </note>

    <note type="performance">
      If query becomes slow (&gt; 5s), consider:
      - Materialized view refreshed hourly
      - Caching results for 1 hour (weekly job runs once)
      - Incremental processing (batch users)
    </note>
  </notes>
</story-context>
