<?xml version="1.0" encoding="UTF-8"?>
<story-context>
  <metadata>
    <story-id>7-6-idempotency-verification-tests</story-id>
    <story-title>Idempotency Verification Tests</story-title>
    <epic>Epic 7: Testing &amp; Quality Assurance</epic>
    <status>ready-for-dev</status>
    <generated-at>2025-11-25</generated-at>
  </metadata>

  <overview>
    <summary>
      Comprehensive test suite verifying idempotency guarantees across all scheduler operations
      to ensure users never receive duplicate proactive messages under any circumstances (NFR7).
      Tests validate three layers: application-level idempotency keys, database constraints,
      and optimistic locking for state transitions.
    </summary>
    <business-value>
      Critical for system reliability and user trust. Duplicate messages erode user confidence
      and cause confusion. This test suite catches idempotency violations before they reach production.
    </business-value>
  </overview>

  <acceptance-criteria>
    <criterion id="AC-7.6.1">
      <description>14-day inactive user processed twice in one day → exactly one goodbye message queued</description>
      <verification>
        - Create user with lastActivityAt = 14 days ago
        - Run daily engagement job twice on same day (same clock state)
        - Assert message queue count = 1 after both runs
        - Verify second run detects user as already processed (skip logic)
      </verification>
    </criterion>

    <criterion id="AC-7.6.2">
      <description>Weekly review job runs multiple times → exactly one message per user</description>
      <verification>
        - Create user eligible for weekly review (Day 8, has activity)
        - Run weekly review job 3 times consecutively
        - Assert message queue count = 1 after all runs
        - Verify idempotency key format: weekly_review_{userId}_{YYYY-MM-DD}
      </verification>
    </criterion>

    <criterion id="AC-7.6.3">
      <description>48h timeout detection runs multiple times → single state transition to dormant</description>
      <verification>
        - Create user in goodbye_sent state, goodbyeExpiresAt = 48 hours ago
        - Run timeout detection logic twice
        - Query engagement_state_transitions table
        - Assert exactly 1 transition record (goodbye_sent → dormant)
        - Verify optimistic locking prevented duplicate transitions
      </verification>
    </criterion>

    <criterion id="AC-7.6.4">
      <description>Message queue processor handles pending messages exactly once</description>
      <verification>
        - Queue 5 messages with status=pending for different users
        - Run processMessageQueue() twice in quick succession
        - Assert all 5 messages have status=sent after first run
        - Verify second run finds 0 pending messages
        - Test retry scenario: failed message increments retry_count, no duplicate created
      </verification>
    </criterion>

    <criterion id="AC-7.6.5">
      <description>Tier completion detection runs twice → single message, unique keys per tier</description>
      <verification>
        - Create user completing Tier 1 (budget_set, first_expense, category_viewed)
        - Run tier completion detection twice
        - Assert message queue count = 1
        - Verify key format: tier_completion_{userId}_tier1_{YYYY-MM-DD}
        - Test cross-tier uniqueness: Tier 1 and Tier 2 messages both allowed
      </verification>
    </criterion>

    <criterion id="AC-7.6.6">
      <description>Scheduler crash mid-execution → recovery skips processed users</description>
      <verification>
        - Create 3 users eligible for goodbye
        - Run daily job, process 2 users, simulate crash before user 3
        - Restart job with full user list
        - Verify users 1-2 skipped (already have messages)
        - Verify user 3 gets message on second run
        - Assert total messages = 3, all unique idempotency keys
      </verification>
    </criterion>

    <criterion id="AC-7.6.7">
      <description>Multiple scheduler instances run simultaneously → database constraints prevent duplicates</description>
      <verification>
        - Create user eligible for goodbye
        - Use Promise.all to run two daily job executions in parallel
        - Verify database uniqueness constraint on idempotency_key blocks duplicate
        - Assert message queue count = 1
        - Test with 5 users: all get exactly 1 message each (no duplicates)
      </verification>
    </criterion>

    <criterion id="AC-7.6.8">
      <description>Concurrent state transitions → optimistic locking ensures single success</description>
      <verification>
        - Create user in active state with updated_at timestamp
        - Simulate two handlers trying to transition active → goodbye_sent
        - First handler succeeds (updated_at increments)
        - Second handler detects optimistic lock conflict (updated_at mismatch)
        - Second handler retries with fresh state
        - Assert only 1 transition record in engagement_state_transitions
      </verification>
    </criterion>

    <criterion id="AC-7.6.9">
      <description>Idempotency key format prevents duplicates correctly</description>
      <verification>
        - Test same-day same-type collision: UPSERT ignores second message
        - Test cross-day uniqueness: both messages allowed (different keys)
        - Test cross-type uniqueness: both messages allowed (different types)
        - Verify key format: {messageType}_{userId}_{YYYY-MM-DD}
        - Test key generation is deterministic (same inputs = same key)
      </verification>
    </criterion>

    <criterion id="AC-7.6.10">
      <description>All idempotency tests pass in &lt; 15 seconds with proper isolation</description>
      <verification>
        - Run: npm test -- idempotency.test.ts
        - Assert all tests pass
        - Assert execution time &lt; 15 seconds
        - Verify no real WhatsApp messages sent (mocked)
        - Verify test database isolated, cleanup complete
      </verification>
    </criterion>
  </acceptance-criteria>

  <technical-context>
    <architecture>
      <idempotency-mechanisms>
        <layer name="application">
          <description>Idempotency keys in message queue prevent duplicate queueing</description>
          <key-format>{messageType}_{userId}_{YYYY-MM-DD}</key-format>
          <example>goodbye_a1b2c3d4-e5f6-7890-abcd-ef1234567890_2025-01-15</example>
          <purpose>Prevents same message type from being queued multiple times for same user on same day</purpose>
          <allows>Different message types on same day, same type on different days</allows>
        </layer>

        <layer name="database">
          <description>Database constraints enforce idempotency at data level</description>
          <constraints>
            <constraint>UNIQUE (idempotency_key)</constraint>
            <constraint>UNIQUE (user_id, message_type, scheduled_for::date)</constraint>
          </constraints>
          <behavior>ON CONFLICT (idempotency_key) DO NOTHING</behavior>
          <purpose>Fail-safe if application-level key generation has bugs</purpose>
        </layer>

        <layer name="concurrency">
          <description>Optimistic locking prevents race conditions in state transitions</description>
          <pattern>updated_at timestamp check before committing state changes</pattern>
          <implementation>
            UPDATE user_engagement_states
            SET state = ?, updated_at = NOW()
            WHERE user_id = ? AND updated_at = ?
          </implementation>
          <behavior>If updated_at mismatch, transaction fails and retries with fresh state</behavior>
        </layer>
      </idempotency-mechanisms>

      <database-schema>
        <table name="engagement_message_queue">
          <file>fe/scripts/034_engagement_system.sql</file>
          <columns>
            <column name="idempotency_key" type="TEXT NOT NULL UNIQUE" description="Unique key preventing duplicates" />
            <column name="user_id" type="UUID NOT NULL" description="User receiving message" />
            <column name="message_type" type="TEXT NOT NULL" description="Type: welcome, tier_unlock, goodbye, weekly_review, reminder, help_restart" />
            <column name="scheduled_for" type="TIMESTAMPTZ NOT NULL" description="When to send message" />
            <column name="status" type="TEXT NOT NULL" description="pending, sent, failed, cancelled" />
            <column name="retry_count" type="INTEGER NOT NULL DEFAULT 0" description="Number of delivery attempts" />
          </columns>
          <indexes>
            <index name="idx_queue_status">On status WHERE status = 'pending'</index>
            <index name="idx_queue_scheduled">On scheduled_for WHERE status = 'pending'</index>
          </indexes>
        </table>

        <table name="user_engagement_states">
          <file>fe/scripts/034_engagement_system.sql</file>
          <columns>
            <column name="user_id" type="UUID NOT NULL UNIQUE" description="User identifier" />
            <column name="state" type="TEXT NOT NULL" description="active, goodbye_sent, help_flow, remind_later, dormant" />
            <column name="updated_at" type="TIMESTAMPTZ NOT NULL" description="For optimistic locking" />
            <column name="last_activity_at" type="TIMESTAMPTZ NOT NULL" description="Last user activity timestamp" />
            <column name="goodbye_sent_at" type="TIMESTAMPTZ" description="When goodbye message was sent" />
            <column name="goodbye_expires_at" type="TIMESTAMPTZ" description="48h timeout expiration" />
          </columns>
          <indexes>
            <index name="idx_engagement_state">On state</index>
            <index name="idx_engagement_last_activity">On last_activity_at</index>
          </indexes>
        </table>

        <table name="engagement_state_transitions">
          <file>fe/scripts/034_engagement_system.sql</file>
          <purpose>Audit log of all state transitions</purpose>
          <columns>
            <column name="user_id" type="UUID NOT NULL" />
            <column name="from_state" type="TEXT NOT NULL" />
            <column name="to_state" type="TEXT NOT NULL" />
            <column name="trigger" type="TEXT NOT NULL" />
            <column name="metadata" type="JSONB" />
            <column name="created_at" type="TIMESTAMPTZ NOT NULL" />
          </columns>
        </table>
      </database-schema>

      <key-services>
        <service name="daily-engagement-job">
          <file>whatsapp-bot/src/services/scheduler/daily-engagement-job.ts</file>
          <responsibility>
            - Process 14-day inactive users → queue goodbye messages
            - Process 48h timeout expirations → transition to dormant
            - Process remind_later expirations → transition to dormant
          </responsibility>
          <idempotency>Re-running job on same day does not create duplicate messages or transitions</idempotency>
        </service>

        <service name="state-machine">
          <file>whatsapp-bot/src/services/engagement/state-machine.ts</file>
          <responsibility>
            - Validate and execute state transitions
            - Optimistic locking for concurrent safety
            - Log transitions to engagement_state_transitions
            - Queue messages as side effects
          </responsibility>
          <idempotency>Concurrent transitions handled via updated_at check</idempotency>
        </service>

        <service name="message-sender">
          <file>whatsapp-bot/src/services/scheduler/message-sender.ts</file>
          <responsibility>
            - Generate idempotency keys
            - Queue messages with UPSERT behavior
            - Process message queue (send pending messages)
            - Retry failed messages (max 3 attempts)
          </responsibility>
          <key-function>getIdempotencyKey(userId, eventType, date)</key-function>
          <key-function>queueMessage(params) - uses UPSERT on idempotency_key</key-function>
        </service>
      </key-services>
    </architecture>

    <test-infrastructure>
      <test-utilities>
        <file>whatsapp-bot/src/__tests__/utils/idempotency-helpers.ts</file>
        <helpers>
          <helper name="runSchedulerTwice">Runs scheduler twice, returns message counts before/after</helper>
          <helper name="assertNoNewMessages">Asserts count didn't change</helper>
          <helper name="getMessageQueueCount">Queries total message count</helper>
          <helper name="seedEngagementState">Inserts test user with engagement state</helper>
          <helper name="cleanupEngagementStates">Deletes test data respecting FK constraints</helper>
          <helper name="getEngagementState">Retrieves user engagement state</helper>
          <helper name="getMessagesForUser">Retrieves queued messages for user</helper>
        </helpers>
      </test-utilities>

      <test-utilities>
        <file>whatsapp-bot/src/__tests__/utils/time-helpers.ts</file>
        <helpers>
          <helper name="setupMockTime">Mock system time for deterministic tests</helper>
          <helper name="advanceTime">Jump forward N days</helper>
          <helper name="resetClock">Restore real time</helper>
        </helpers>
      </test-utilities>

      <test-utilities>
        <file>whatsapp-bot/src/__tests__/utils/test-database.ts</file>
        <helpers>
          <helper name="getTestSupabaseClient">Returns Supabase client for test DB</helper>
          <helper name="createTestUser">Creates user in auth.users table</helper>
        </helpers>
      </test-utilities>

      <mocks>
        <file>whatsapp-bot/src/__mocks__/baileys.ts</file>
        <purpose>Mock WhatsApp sendMessage to prevent real sends during tests</purpose>
      </mocks>

      <mocks>
        <file>whatsapp-bot/src/__mocks__/openai.ts</file>
        <purpose>Mock OpenAI API calls for NLP operations</purpose>
      </mocks>
    </test-infrastructure>

    <critical-edge-cases>
      <case id="same-day-rerun">
        <scenario>Daily job runs twice on same day (Railway cron glitch)</scenario>
        <expected>First run queues messages, second run skips users (idempotency keys exist)</expected>
        <test>AC-7.6.1, AC-7.6.2</test>
      </case>

      <case id="cross-day-uniqueness">
        <scenario>User gets goodbye on Day 15, still inactive on Day 16</scenario>
        <expected>Day 16 job queues another goodbye (different date in key)</expected>
        <test>AC-7.6.9</test>
        <rationale>User may need multiple reminders across multiple days</rationale>
      </case>

      <case id="crash-recovery">
        <scenario>Job processes 30/50 users, crashes, restarts with full list</scenario>
        <expected>First 30 users skipped (messages exist), last 20 processed</expected>
        <test>AC-7.6.6</test>
      </case>

      <case id="concurrent-instances">
        <scenario>Railway spawns two cron jobs simultaneously</scenario>
        <expected>Database constraint blocks duplicate inserts, one succeeds</expected>
        <test>AC-7.6.7</test>
      </case>

      <case id="optimistic-lock-race">
        <scenario>Two handlers try to update same user state simultaneously</scenario>
        <expected>First succeeds, second detects updated_at mismatch and retries</expected>
        <test>AC-7.6.8</test>
      </case>
    </critical-edge-cases>

    <performance-targets>
      <target metric="execution-time">All tests complete in &lt; 15 seconds</target>
      <target metric="test-count">10 test scenarios (one per AC)</target>
      <target metric="average-per-test">~1.5 seconds per test</target>
      <optimization>Skip unnecessary time advances, batch DB operations, mock external services</optimization>
    </performance-targets>
  </technical-context>

  <implementation-guide>
    <test-file>
      <path>whatsapp-bot/src/__tests__/engagement/idempotency.test.ts</path>
      <structure>
        <describe>Idempotency Verification Tests</describe>
        <setup>
          <beforeEach>Reset time, clean DB, initialize mocks</beforeEach>
          <afterEach>Cleanup test users via cleanupEngagementStates()</afterEach>
        </setup>
        <tests>
          <test>Daily job runs twice - no duplicate goodbye messages (AC-7.6.1)</test>
          <test>Weekly review job runs multiple times - single message (AC-7.6.2)</test>
          <test>48h timeout runs multiple times - single transition (AC-7.6.3)</test>
          <test>Message queue processor handles pending messages once (AC-7.6.4)</test>
          <test>Tier completion detection twice - single message (AC-7.6.5)</test>
          <test>Scheduler crash recovery - skips processed users (AC-7.6.6)</test>
          <test>Multiple scheduler instances - no duplicates (AC-7.6.7)</test>
          <test>Concurrent state transitions - optimistic locking (AC-7.6.8)</test>
          <test>Idempotency key format prevents duplicates (AC-7.6.9)</test>
        </tests>
      </structure>
    </test-file>

    <new-utilities>
      <utility name="runSchedulerTwice">
        <location>whatsapp-bot/src/__tests__/utils/idempotency-helpers.ts</location>
        <description>Runs scheduler function twice with same clock state, returns message counts</description>
        <note>Already exists in idempotency-helpers.ts (from Story 7.1)</note>
      </utility>

      <utility name="simulateCrash">
        <location>whatsapp-bot/src/__tests__/utils/idempotency-helpers.ts</location>
        <description>Runs scheduler, throws error after processing N users</description>
        <status>NEW - needs to be added</status>
      </utility>

      <utility name="runConcurrently">
        <location>whatsapp-bot/src/__tests__/utils/idempotency-helpers.ts</location>
        <description>Uses Promise.all to run two functions in parallel</description>
        <status>NEW - needs to be added</status>
      </utility>
    </new-utilities>

    <assertion-patterns>
      <pattern name="message-count">
        <code>
          const messages = await getMessagesForUser(userId)
          expect(messages).toHaveLength(1)
          expect(messages[0].message_type).toBe('goodbye')
        </code>
      </pattern>

      <pattern name="transition-count">
        <code>
          const { data: transitions } = await supabase
            .from('engagement_state_transitions')
            .select('*')
            .eq('user_id', userId)
            .eq('to_state', 'dormant')
          expect(transitions).toHaveLength(1)
        </code>
      </pattern>

      <pattern name="idempotency-key-format">
        <code>
          const key = getIdempotencyKey(userId, 'goodbye', new Date('2025-01-15'))
          expect(key).toBe(`goodbye_${userId}_2025-01-15`)
        </code>
      </pattern>

      <pattern name="scheduler-twice">
        <code>
          const { messagesAfterFirst, messagesAfterSecond } = await runSchedulerTwice(runDailyEngagementJob)
          assertNoNewMessages(messagesAfterFirst, messagesAfterSecond)
        </code>
      </pattern>
    </assertion-patterns>
  </implementation-guide>

  <traceability>
    <requirements>
      <prd-requirement id="FR19">Idempotent scheduler - no duplicate messages on re-runs</prd-requirement>
      <prd-requirement id="FR47">Message queue guarantees - exactly-once delivery semantics</prd-requirement>
      <prd-requirement id="FR53">Idempotency verification tests - comprehensive test suite</prd-requirement>
      <nfr-requirement id="NFR7">No duplicate proactive messages under any circumstances</nfr-requirement>
      <nfr-requirement id="NFR4">99.9% scheduler success rate - crash recovery resilience</nfr-requirement>
    </requirements>

    <epic-tech-spec>
      <reference>docs/sprint-artifacts/tech-spec-epic-7.md#AC-7.6-Idempotency-Guaranteed</reference>
      <ac id="AC-7.6.1">Scheduler re-run → runSchedulerTwice() → zero new messages</ac>
      <ac id="AC-7.6.2">Message queue → duplicate idempotency key → upsert ignores</ac>
      <ac id="AC-7.6.3">State machine → same transition twice → no error, single log entry</ac>
    </epic-tech-spec>

    <dependencies>
      <story id="7.1" type="test-infrastructure">E2E testing framework setup - test utilities, mocks, fixtures</story>
      <story id="7.2" type="validation">State machine unit tests - validates transitions work correctly</story>
      <story id="7.3" type="validation">Scheduler unit tests - validates jobs work correctly</story>
      <story id="7.5" type="integration">30-day journey tests - validates no duplicates in full flows</story>
    </dependencies>
  </traceability>

  <testing-strategy>
    <approach>
      <level>Integration tests (30% of test pyramid)</level>
      <rationale>
        Idempotency must be tested with real database operations. Mocking would not validate
        actual uniqueness constraints, UPSERT behavior, or optimistic locking mechanics.
      </rationale>
      <database>Test Supabase instance with real schema</database>
      <mocks>WhatsApp (Baileys), OpenAI - prevent external calls</mocks>
      <isolation>Each test gets clean database state via setup/teardown</isolation>
    </approach>

    <test-scenarios>
      <scenario name="Daily job idempotency">
        <setup>Create user 14 days inactive</setup>
        <action>Run daily job twice on same day</action>
        <assert>Exactly 1 goodbye message in queue</assert>
      </scenario>

      <scenario name="Weekly review idempotency">
        <setup>Create user eligible for weekly review</setup>
        <action>Run weekly job 3 times</action>
        <assert>Exactly 1 weekly_review message in queue</assert>
      </scenario>

      <scenario name="Timeout idempotency">
        <setup>Create user in goodbye_sent, expired 48h ago</setup>
        <action>Run timeout detection twice</action>
        <assert>Exactly 1 transition record to dormant</assert>
      </scenario>

      <scenario name="Queue processor idempotency">
        <setup>Queue 5 pending messages</setup>
        <action>Run processMessageQueue() twice</action>
        <assert>All 5 sent after first run, 0 pending after second</assert>
      </scenario>

      <scenario name="Crash recovery">
        <setup>Create 3 users eligible for goodbye</setup>
        <action>Process 2, crash, restart with all 3</action>
        <assert>First 2 skipped, third processed, total messages = 3</assert>
      </scenario>

      <scenario name="Concurrent schedulers">
        <setup>Create 1 user eligible for goodbye</setup>
        <action>Run two daily jobs in parallel (Promise.all)</action>
        <assert>Database constraint prevents duplicate, count = 1</assert>
      </scenario>

      <scenario name="Concurrent state changes">
        <setup>Create user in active state</setup>
        <action>Two handlers try active → goodbye_sent simultaneously</action>
        <assert>One succeeds, one retries, final transitions count = 1</assert>
      </scenario>

      <scenario name="Key format validation">
        <setup>Generate keys for various scenarios</setup>
        <action>Test same-day, cross-day, cross-type collisions</action>
        <assert>Keys prevent same-day same-type, allow others</assert>
      </scenario>
    </test-scenarios>

    <observability>
      <logging>
        - Test scenario name at start
        - Scheduler run number (Run 1, Run 2)
        - Message queue state after each run
        - Idempotency key collisions detected
      </logging>
      <error-messages>
        - "Expected 1 message but found {count}. Idempotency failed!"
        - "Found duplicate idempotency keys: [{keys}]"
        - "Expected transition record not found"
      </error-messages>
      <performance-tracking>
        - Measure scheduler run time (should be faster on second run)
        - Log: "Daily job run 1: 120ms, run 2: 45ms (skipped processed users)"
      </performance-tracking>
    </observability>
  </testing-strategy>

  <definition-of-done>
    <checklist>
      <item>✓ All 10 AC scenarios have corresponding test cases</item>
      <item>✓ Test file created: whatsapp-bot/src/__tests__/engagement/idempotency.test.ts</item>
      <item>✓ New utilities added to idempotency-helpers.ts: simulateCrash(), runConcurrently()</item>
      <item>✓ All tests pass: npm test -- idempotency.test.ts</item>
      <item>✓ Execution time &lt; 15 seconds</item>
      <item>✓ No flaky tests (run suite 3x, all pass each time)</item>
      <item>✓ Test coverage for critical edge cases: crash recovery, concurrent instances, optimistic locking</item>
      <item>✓ Structured logging in tests for observability</item>
      <item>✓ Custom error messages for failed assertions</item>
      <item>✓ Database constraints validated (UNIQUE on idempotency_key)</item>
      <item>✓ Optimistic locking validated (updated_at check)</item>
      <item>✓ Idempotency key format validated (deterministic, day-level precision)</item>
      <item>✓ JSDoc comments added to new test utilities</item>
      <item>✓ Test isolation verified (no leftover data between tests)</item>
      <item>✓ No real WhatsApp messages sent (Baileys mocked)</item>
    </checklist>
  </definition-of-done>

  <references>
    <document type="tech-spec">docs/sprint-artifacts/tech-spec-epic-7.md#AC-7.6-Idempotency-Guaranteed</document>
    <document type="workflow">docs/sprint-artifacts/tech-spec-epic-7.md#Idempotency-Test-Workflow</document>
    <document type="nfr">docs/sprint-artifacts/tech-spec-epic-7.md#NFR7-No-Duplicate-Messages</document>
    <document type="story">docs/sprint-artifacts/7-1-e2e-testing-framework-setup.md#Test-Infrastructure</document>
    <document type="story">docs/sprint-artifacts/7-3-scheduler-unit-tests.md#Scheduler-Timing</document>
    <document type="story">docs/sprint-artifacts/7-5-30-day-journey-integration-test.md#Idempotency-Verification</document>
    <code-file>whatsapp-bot/src/services/scheduler/daily-engagement-job.ts</code-file>
    <code-file>whatsapp-bot/src/services/engagement/state-machine.ts</code-file>
    <code-file>whatsapp-bot/src/services/scheduler/message-sender.ts</code-file>
    <code-file>whatsapp-bot/src/__tests__/utils/idempotency-helpers.ts</code-file>
    <schema-file>fe/scripts/034_engagement_system.sql</schema-file>
  </references>
</story-context>
