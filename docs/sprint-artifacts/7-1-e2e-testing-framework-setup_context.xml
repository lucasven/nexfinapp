<?xml version="1.0" encoding="UTF-8"?>
<story-context>
  <metadata>
    <story-id>7-1-e2e-testing-framework-setup</story-id>
    <epic-id>epic-7</epic-id>
    <generated-at>2025-11-24</generated-at>
    <status>ready-for-dev</status>
  </metadata>

  <story-overview>
    <title>E2E Testing Framework Setup</title>
    <description>
      Establish comprehensive E2E testing infrastructure for the Smart Onboarding &amp; Engagement System,
      including mocked WhatsApp client, time manipulation utilities, test data fixtures, and idempotency
      test helpers. This story creates the foundation for Stories 7.2-7.6.
    </description>
    <user-story>
      As a developer working on the Smart Onboarding &amp; Engagement System,
      I want a comprehensive E2E testing framework with mocked WhatsApp and test utilities,
      So that I can write reliable tests for engagement features without real WhatsApp connections.
    </user-story>
  </story-overview>

  <architecture-context>
    <existing-test-infrastructure>
      <description>
        The whatsapp-bot codebase already has established test patterns and infrastructure:
        - Jest test framework with ts-jest for TypeScript ESM modules (jest.config.js)
        - 70% coverage threshold across branches, functions, lines, statements
        - Existing mocks for Supabase, OpenAI, and Baileys in src/__mocks__/
        - Test setup file at src/__tests__/setup.ts that mocks external dependencies
        - Factory patterns for test data in src/__tests__/utils/test-helpers.ts
        - Test structure mirrors source: __tests__/ directories alongside implementation
      </description>

      <existing-files>
        <file path="whatsapp-bot/jest.config.js">
          Jest configuration with ts-jest preset, ESM support, 70% coverage threshold.
          Already configured with moduleNameMapper for .js extension handling.
        </file>
        <file path="whatsapp-bot/src/__tests__/setup.ts">
          Global test setup that mocks Supabase, Baileys, and OpenAI.
          Mocks console methods to reduce noise in tests.
        </file>
        <file path="whatsapp-bot/src/__mocks__/baileys.ts">
          Existing Baileys mock with mockBaileysClient, makeWASocket, DisconnectReason, ConnectionState.
          Provides sendMessage mock and resetBaileysMocks helper.
          THIS ALREADY EXISTS - Story needs to EXTEND this, not recreate it.
        </file>
        <file path="whatsapp-bot/src/__tests__/utils/test-helpers.ts">
          Existing test helpers: createMockUserSession, createMockExpenseData, createMockParsedIntent.
          Provides expectIntentToMatch, expectExpenseDataToMatch assertion helpers.
          Pattern to follow for new engagement fixtures.
        </file>
        <file path="whatsapp-bot/src/__tests__/utils/mock-data.ts">
          Existing mock data: mockUsers, mockTransactions, mockCategories, mockBudgets, mockRecurringTransactions.
          Pattern to follow for engagement mock data.
        </file>
      </existing-files>

      <existing-test-patterns>
        <pattern name="Factory Functions">
          Use factory functions like createMockUserSession(overrides) that accept partial overrides.
          Provide sensible defaults, allow specific fields to be overridden.
        </pattern>
        <pattern name="Test Isolation">
          beforeEach() seeds necessary data, afterEach() cleans up test users.
          Generate unique user IDs (UUIDs) to prevent test collisions.
        </pattern>
        <pattern name="Mock Reset">
          Use jest.clearAllMocks() in beforeEach() to reset mock state.
          Provide explicit reset helpers like resetBaileysMocks().
        </pattern>
      </existing-test-patterns>
    </existing-test-infrastructure>

    <engagement-system-architecture>
      <description>
        The Smart Onboarding &amp; Engagement System (Epics 1-6) implements a 5-state machine
        with time-based transitions and proactive messaging. Testing this system requires:
        1. Mocking time to simulate day/hour progression
        2. Mocking WhatsApp to capture sent messages
        3. Fixtures to create engagement states at specific points in time
        4. Helpers to verify idempotency (no duplicate messages)
      </description>

      <state-machine>
        <states>
          <state name="active">Default state, user is actively using the app</state>
          <state name="goodbye_sent">14 days inactive, goodbye message sent, awaiting response</state>
          <state name="help_flow">User selected "I'm confused" from goodbye, restart Tier 1</state>
          <state name="remind_later">User selected "Remind me later" from goodbye, 30-day reminder</state>
          <state name="dormant">User selected "Taking a break" or 48h timeout after goodbye</state>
        </states>

        <transitions>
          <transition from="active" to="goodbye_sent" trigger="inactivity_14d">
            After 14 days of inactivity, daily scheduler sends goodbye message
          </transition>
          <transition from="goodbye_sent" to="active" trigger="goodbye_response_3">
            User responds with option 3 ("I'm still here")
          </transition>
          <transition from="goodbye_sent" to="help_flow" trigger="goodbye_response_1">
            User responds with option 1 ("I'm confused")
          </transition>
          <transition from="goodbye_sent" to="remind_later" trigger="goodbye_response_2">
            User responds with option 2 ("Remind me later")
          </transition>
          <transition from="goodbye_sent" to="dormant" trigger="goodbye_timeout">
            48 hours pass without response after goodbye message
          </transition>
          <transition from="help_flow" to="active" trigger="user_message">
            After help flow, user returns to active
          </transition>
          <transition from="remind_later" to="active" trigger="user_message">
            User sends message before 30-day reminder expires
          </transition>
          <transition from="remind_later" to="dormant" trigger="reminder_due">
            30 days pass, reminder expires
          </transition>
          <transition from="dormant" to="active" trigger="user_message">
            User returns after dormancy
          </transition>
        </transitions>
      </state-machine>

      <database-schema>
        <table name="user_engagement_states">
          <description>Tracks current engagement state for each user</description>
          <columns>
            <column name="id" type="uuid">Primary key</column>
            <column name="user_id" type="uuid">Foreign key to users table</column>
            <column name="state" type="text">Current engagement state (active|goodbye_sent|help_flow|remind_later|dormant)</column>
            <column name="last_activity_at" type="timestamp">Timestamp of last user activity</column>
            <column name="goodbye_sent_at" type="timestamp">Timestamp when goodbye message was sent</column>
            <column name="goodbye_expires_at" type="timestamp">48h after goodbye_sent_at</column>
            <column name="remind_at" type="timestamp">30 days after goodbye for remind_later state</column>
            <column name="created_at" type="timestamp">Record creation time</column>
            <column name="updated_at" type="timestamp">Record update time</column>
          </columns>
        </table>

        <table name="engagement_message_queue">
          <description>Queue for proactive messages to be sent by scheduler</description>
          <columns>
            <column name="id" type="uuid">Primary key</column>
            <column name="user_id" type="uuid">Foreign key to users table</column>
            <column name="message_type" type="text">Type of message (welcome|tier_unlock|goodbye|weekly_review|reminder|help_restart)</column>
            <column name="destination" type="text">individual|group</column>
            <column name="status" type="text">pending|sent|failed|cancelled</column>
            <column name="retry_count" type="integer">Number of retry attempts</column>
            <column name="idempotency_key" type="text">Unique key to prevent duplicate messages</column>
            <column name="created_at" type="timestamp">Record creation time</column>
          </columns>
        </table>

        <table name="engagement_state_transitions">
          <description>Audit log of all state transitions for analytics</description>
          <columns>
            <column name="id" type="uuid">Primary key</column>
            <column name="user_id" type="uuid">Foreign key to users table</column>
            <column name="from_state" type="text">Previous state</column>
            <column name="to_state" type="text">New state</column>
            <column name="trigger" type="text">What caused the transition</column>
            <column name="metadata" type="jsonb">Additional context (days_inactive, response_type, etc.)</column>
            <column name="created_at" type="timestamp">Transition time</column>
          </columns>
        </table>
      </database-schema>

      <typescript-types>
        <file path="whatsapp-bot/src/services/engagement/types.ts">
          Defines all engagement system types:
          - EngagementState: 'active' | 'goodbye_sent' | 'help_flow' | 'remind_later' | 'dormant'
          - TransitionTrigger: user_message, inactivity_14d, goodbye_response_1/2/3, goodbye_timeout, reminder_due
          - MessageType: welcome, tier_unlock, goodbye, weekly_review, reminder, help_restart
          - UserEngagementState interface matching database table
          - QueuedMessage interface (NOTE: story uses EngagementMessageQueue, same as QueuedMessage)
          - TierProgress interface for tier tracking
          - TRANSITION_MAP: state + trigger → new state
        </file>
      </typescript-types>
    </engagement-system-architecture>

    <adr-context>
      <adr id="ADR-004">
        <title>Jest + Mocks for WhatsApp Testing</title>
        <decision>
          Use Jest mocks for Baileys WhatsApp client instead of real WhatsApp integration tests.
          Real WhatsApp testing is too flaky and risks account bans. Mocks cover 95% of logic.
          Manual QA covers last mile before major releases.
        </decision>
        <impact-on-story>
          Story 7.1 extends existing Baileys mock to capture sent messages for assertions.
          Must provide getMockMessages() and clearMockMessages() helpers.
        </impact-on-story>
      </adr>

      <adr id="ADR-003">
        <title>Message Queue for Proactive Messages</title>
        <decision>
          All proactive messages go through engagement_message_queue table before sending.
          Provides idempotency, retry logic, and audit trail.
        </decision>
        <impact-on-story>
          Tests need to query message queue table to verify messages were queued.
          Fixtures must support creating mock message queue entries.
        </impact-on-story>
      </adr>

      <adr id="ADR-005">
        <title>Single Daily Job for Engagement</title>
        <decision>
          Use single daily cron job (Railway cron.yml) instead of distributed timers.
          Simplifies scheduler logic and testing.
        </decision>
        <impact-on-story>
          Time manipulation helpers must support advancing time by days.
          Tests simulate daily job runs at specific dates.
        </impact-on-story>
      </adr>
    </adr-context>
  </architecture-context>

  <implementation-context>
    <critical-patterns>
      <pattern name="Time Manipulation">
        <description>
          Use Jest fake timers to control time in tests. Must manipulate both:
          1. Jest timers (jest.advanceTimersByTime) for setTimeout/setInterval
          2. System time (jest.setSystemTime) for Date.now() and new Date()
        </description>
        <example><![CDATA[
export function setupMockTime(startDate: Date = new Date()) {
  jest.useFakeTimers()
  jest.setSystemTime(startDate)
  return startDate
}

export function advanceTime(days: number): Date {
  const millisecondsPerDay = 24 * 60 * 60 * 1000
  const newTime = Date.now() + (days * millisecondsPerDay)
  jest.setSystemTime(newTime)
  jest.advanceTimersByTime(days * millisecondsPerDay)
  return new Date(newTime)
}

export function resetClock() {
  jest.useRealTimers()
}
        ]]></example>
      </pattern>

      <pattern name="Baileys Mock Extension">
        <description>
          EXTEND existing mock at src/__mocks__/baileys.ts, do not recreate.
          Add helpers to capture and retrieve sent messages:
          - mockMessages array to store sent messages
          - getMockMessages() to retrieve sent messages
          - clearMockMessages() to reset between tests
        </description>
        <example><![CDATA[
// Extend existing mock
let mockMessages: Array<{ jid: string; message: any }> = []

// Update existing sendMessage mock to capture messages
mockBaileysClient.sendMessage = jest.fn().mockImplementation(async (jid: string, message: any) => {
  mockMessages.push({ jid, message })
  return { key: { id: `test-message-${mockMessages.length}` } }
})

// New helpers
export function getMockMessages() {
  return mockMessages
}

export function clearMockMessages() {
  mockMessages = []
}
        ]]></example>
      </pattern>

      <pattern name="Fixture Factory Functions">
        <description>
          Follow existing pattern from test-helpers.ts: factory functions with sensible defaults
          that accept partial overrides. Generate unique IDs if not provided.
        </description>
        <example><![CDATA[
import { v4 as uuidv4 } from 'uuid'

export function createMockEngagementState(
  options: MockEngagementStateOptions = {}
): UserEngagementState {
  return {
    id: options.id ?? uuidv4(),
    userId: options.userId ?? uuidv4(),
    state: options.state ?? 'active',
    lastActivityAt: options.lastActivityAt ?? new Date(),
    goodbyeSentAt: options.goodbyeSentAt ?? null,
    goodbyeExpiresAt: options.goodbyeExpiresAt ?? null,
    remindAt: options.remindAt ?? null,
    createdAt: options.createdAt ?? new Date(),
    updatedAt: options.updatedAt ?? new Date(),
  }
}
        ]]></example>
      </pattern>

      <pattern name="Idempotency Testing">
        <description>
          Critical requirement: scheduler must never send duplicate messages.
          Pattern: run scheduler twice with same clock state, verify no new messages.
        </description>
        <example><![CDATA[
export async function runSchedulerTwice(
  schedulerFn: () => Promise<void>
): Promise<{ messagesBefore: number; messagesAfterFirst: number; messagesAfterSecond: number }> {
  const messagesBefore = await getMessageQueueCount()

  // First run
  await schedulerFn()
  const messagesAfterFirst = await getMessageQueueCount()

  // Second run (same clock state - should be idempotent)
  await schedulerFn()
  const messagesAfterSecond = await getMessageQueueCount()

  return { messagesBefore, messagesAfterFirst, messagesAfterSecond }
}

export function assertNoNewMessages(countBefore: number, countAfter: number) {
  expect(countAfter).toBe(countBefore)
}
        ]]></example>
      </pattern>

      <pattern name="Test Database Helpers">
        <description>
          Provide helpers to seed engagement state and clean up after tests.
          Use test database connection (mocked Supabase client from __mocks__/supabase.ts).
        </description>
        <example><![CDATA[
export async function seedEngagementState(
  state: UserEngagementState
): Promise<UserEngagementState> {
  const { data, error } = await supabaseTest
    .from('user_engagement_states')
    .insert(state)
    .select()
    .single()

  if (error) throw error
  return data
}

export async function cleanupEngagementStates(userIds: string[]) {
  // Clean up in order (foreign key constraints)
  await supabaseTest.from('engagement_state_transitions').delete().in('user_id', userIds)
  await supabaseTest.from('engagement_message_queue').delete().in('user_id', userIds)
  await supabaseTest.from('user_engagement_states').delete().in('user_id', userIds)
}
        ]]></example>
      </pattern>
    </critical-patterns>

    <files-to-create>
      <file path="whatsapp-bot/src/__tests__/engagement/fixtures/engagement-fixtures.ts">
        <purpose>Test data factory functions for engagement system</purpose>
        <exports>
          - MockEngagementStateOptions interface
          - MockMessageQueueOptions interface
          - createMockEngagementState(options)
          - createMockMessageQueue(options)
          - createMockTierProgress(tier, completedActions)
          - createCompleteTierProgress(userId)
          - createBulkMockMessages(count, baseOptions)
        </exports>
        <dependencies>
          - whatsapp-bot/src/services/engagement/types.ts (UserEngagementState, QueuedMessage types)
          - uuid (for generating unique IDs)
        </dependencies>
      </file>

      <file path="whatsapp-bot/src/__tests__/utils/time-helpers.ts">
        <purpose>Time manipulation utilities for testing time-based features</purpose>
        <exports>
          - setupMockTime(startDate?: Date): Date
          - mockNow(date: Date): void
          - advanceTime(days: number): Date
          - resetClock(): void
        </exports>
        <dependencies>
          - Jest (jest.useFakeTimers, jest.setSystemTime, jest.advanceTimersByTime, jest.useRealTimers)
        </dependencies>
      </file>

      <file path="whatsapp-bot/src/__tests__/utils/idempotency-helpers.ts">
        <purpose>Scheduler test utilities for verifying idempotency</purpose>
        <exports>
          - runSchedulerTwice(schedulerFn: () => Promise&lt;void&gt;): Promise&lt;object&gt;
          - assertNoNewMessages(countBefore: number, countAfter: number): void
          - getMessageQueueCount(): Promise&lt;number&gt;
          - seedEngagementState(state: UserEngagementState): Promise&lt;UserEngagementState&gt;
          - cleanupEngagementStates(userIds: string[]): Promise&lt;void&gt;
          - getEngagementState(userId: string): Promise&lt;UserEngagementState | null&gt;
        </exports>
        <dependencies>
          - Mocked Supabase client from __mocks__/supabase.ts
          - whatsapp-bot/src/services/engagement/types.ts
        </dependencies>
      </file>

      <file path="whatsapp-bot/src/__tests__/engagement/example.test.ts">
        <purpose>Example integration test to validate all infrastructure works</purpose>
        <test-coverage>
          - Creates engagement state and sends goodbye message after 14 days
          - Uses createMockEngagementState, advanceTime, getMockMessages
          - Validates full test infrastructure is working
        </test-coverage>
        <dependencies>
          - All new test utilities (fixtures, time-helpers, idempotency-helpers)
          - Mocked Baileys client
          - Scheduler service (will be implemented in Story 7.3, but test structure can be drafted)
        </dependencies>
      </file>
    </files-to-create>

    <files-to-modify>
      <file path="whatsapp-bot/src/__mocks__/baileys.ts">
        <changes>
          - Add mockMessages array to capture sent messages
          - Update mockBaileysClient.sendMessage to push to mockMessages array
          - Add getMockMessages() export
          - Add clearMockMessages() export
          - Update resetBaileysMocks() to also clear mockMessages array
        </changes>
        <existing-content>
          Already has mockBaileysClient with sendMessage mock, makeWASocket, DisconnectReason, ConnectionState, resetBaileysMocks.
        </existing-content>
      </file>

      <file path="whatsapp-bot/jest.config.js">
        <changes>
          - Verify configuration (likely no changes needed)
          - Ensure setupFilesAfterEnv points to src/__tests__/setup.ts (already configured)
          - Ensure coverageThreshold is 70% (already configured)
          - Ensure moduleNameMapper handles .js extensions (already configured)
        </changes>
        <existing-content>
          Already properly configured with ts-jest, ESM support, 70% coverage threshold.
        </existing-content>
      </file>

      <file path="whatsapp-bot/src/__tests__/setup.ts">
        <changes>
          - Verify mocks are set up correctly (likely no changes needed)
          - Potentially add jest.useFakeTimers() by default if all tests need it
          - Consider adding global test database connection setup
        </changes>
        <existing-content>
          Already mocks Supabase, Baileys, OpenAI, and dotenv. Mocks console methods.
        </existing-content>
      </file>
    </files-to-modify>

    <dependencies>
      <existing-dependencies>
        <dependency name="jest" version="^29.7.0">Test framework</dependency>
        <dependency name="ts-jest" version="^29.1.1">TypeScript preprocessor for Jest</dependency>
        <dependency name="@types/jest" version="^29.5.8">TypeScript types for Jest</dependency>
      </existing-dependencies>
      <no-new-dependencies>
        All required dependencies already in package.json. No new packages needed.
      </no-new-dependencies>
    </dependencies>
  </implementation-context>

  <testing-strategy>
    <story-validation>
      <description>
        Story 7.1 is meta—it creates test infrastructure. Validation is:
        1. All imports resolve without errors
        2. Example test passes
        3. npm test runs successfully on clean install
        4. Mocks and fixtures are usable in subsequent stories
      </description>
      <validation-tests>
        <test name="All imports resolve">
          Import all new modules in example.test.ts and verify no import errors
        </test>
        <test name="Example test passes">
          Run example.test.ts and verify it passes (simulates 14-day journey)
        </test>
        <test name="npm test runs successfully">
          Run npm test on clean install and verify all infrastructure is available
        </test>
        <test name="Fixtures create valid objects">
          Verify createMockEngagementState returns object matching UserEngagementState schema
        </test>
        <test name="Time helpers manipulate time">
          Verify advanceTime(1) advances Date.now() by 24 hours
        </test>
        <test name="Baileys mock captures messages">
          Verify getMockMessages() returns messages sent via mockBaileysClient.sendMessage
        </test>
      </validation-tests>
    </story-validation>

    <no-extensive-unit-tests>
      Story 7.1 test utilities will be validated by their usage in Stories 7.2-7.6.
      Focus on example test that exercises all utilities together.
    </no-extensive-unit-tests>
  </testing-strategy>

  <acceptance-criteria>
    <criterion id="AC-7.1.1">
      <description>
        Given the test suite runs, when Baileys WhatsApp client is needed, then a mock implementation
        in __mocks__/baileys.ts provides mockSendMessage() function that captures message calls without
        real connections, and test assertions can verify messages sent.
      </description>
      <validation>
        1. Extend existing Baileys mock with mockMessages array
        2. Update sendMessage mock to capture messages
        3. Provide getMockMessages() and clearMockMessages() helpers
        4. Test in example.test.ts by sending message and verifying it's captured
      </validation>
    </criterion>

    <criterion id="AC-7.1.2">
      <description>
        Given a test needs to simulate time progression, when advanceTime(days: number) is called from
        __tests__/utils/time-helpers.ts, then Jest timers advance by the specified duration, and database
        timestamps can be updated to match the new time for scheduler testing.
      </description>
      <validation>
        1. Create time-helpers.ts with setupMockTime, advanceTime, resetClock
        2. advanceTime must update both jest.setSystemTime and jest.advanceTimersByTime
        3. Test in example.test.ts by advancing 14 days and verifying Date.now() changed
      </validation>
    </criterion>

    <criterion id="AC-7.1.3">
      <description>
        Given a test needs engagement state data, when createMockEngagementState(options) is called from
        __tests__/engagement/fixtures/engagement-fixtures.ts, then a valid test UserEngagementState object
        is returned with specified or default values for state, lastActivityAt, goodbyeSentAt, etc.
      </description>
      <validation>
        1. Create engagement-fixtures.ts with createMockEngagementState
        2. Support MockEngagementStateOptions interface with all optional fields
        3. Provide sensible defaults (state='active', lastActivityAt=now, others=null)
        4. Test by creating state with no args and verify defaults, then with overrides
      </validation>
    </criterion>

    <criterion id="AC-7.1.4">
      <description>
        Given a test needs message queue data, when createMockMessageQueue(options) is called from fixtures,
        then a valid EngagementMessageQueue object is returned with specified or default values for userId,
        messageType, destination, status, idempotencyKey.
      </description>
      <validation>
        1. Add createMockMessageQueue to engagement-fixtures.ts
        2. Support MockMessageQueueOptions interface
        3. Generate unique idempotencyKey if not provided
        4. Test by creating queue entry and verifying structure matches QueuedMessage type
      </validation>
    </criterion>

    <criterion id="AC-7.1.5">
      <description>
        Given a test needs to verify scheduler idempotency, when runSchedulerTwice() is called from
        __tests__/utils/idempotency-helpers.ts, then the scheduler runs twice with the same clock state,
        and assertNoNewMessages() verifies no duplicate messages were queued.
      </description>
      <validation>
        1. Create idempotency-helpers.ts with runSchedulerTwice and assertNoNewMessages
        2. runSchedulerTwice queries message queue before/after first run, then after second run
        3. assertNoNewMessages uses expect(countAfter).toBe(countBefore)
        4. Test structure in example.test.ts (actual scheduler test in Story 7.3)
      </validation>
    </criterion>

    <criterion id="AC-7.1.6">
      <description>
        Given a test needs to reset time state, when resetClock() is called from time-helpers, then Jest
        timers are restored to real time, and subsequent tests start with clean time state.
      </description>
      <validation>
        1. Implement resetClock() calling jest.useRealTimers()
        2. Use in afterEach() blocks to clean up
        3. Test by setting fake time, resetting, and verifying Date.now() is real time
      </validation>
    </criterion>

    <criterion id="AC-7.1.7">
      <description>
        Given a developer runs npm test on a clean install, when the test command executes, then all test
        infrastructure is available, no import errors occur, and example tests using mocks and fixtures
        pass successfully.
      </description>
      <validation>
        1. Create example.test.ts that imports and uses all new utilities
        2. Run npm test and verify no import errors
        3. Verify example test passes (may mock scheduler for now)
        4. Document usage in JSDoc comments for all public functions
      </validation>
    </criterion>
  </acceptance-criteria>

  <dev-notes>
    <note priority="critical">
      DO NOT recreate existing mocks. The Baileys mock already exists at src/__mocks__/baileys.ts.
      EXTEND it by adding mockMessages array and helper functions. Review existing mock first.
    </note>

    <note priority="critical">
      Follow existing test patterns from test-helpers.ts and mock-data.ts. The codebase has established
      patterns for factory functions, mock data, and test structure. Maintain consistency.
    </note>

    <note priority="high">
      Time manipulation must handle both jest.setSystemTime (for Date.now()) and jest.advanceTimersByTime
      (for setTimeout/setInterval). Scheduler tests will rely on accurate time control.
    </note>

    <note priority="high">
      Test database helpers should use the mocked Supabase client, but understand that in integration tests
      they may connect to a real test database. Design helpers to work in both scenarios.
    </note>

    <note priority="medium">
      Generate unique IDs using uuid v4. Import from 'uuid' package (already in dependencies).
      This prevents test collisions when running tests in parallel.
    </note>

    <note priority="medium">
      JSDoc comments are required for all public functions. Include usage examples in comments.
      This documentation will help developers using the test utilities in Stories 7.2-7.6.
    </note>

    <note priority="low">
      Example test may need to mock the scheduler service since it's not fully implemented yet.
      The goal is to demonstrate that all infrastructure works, not to test the scheduler itself.
    </note>
  </dev-notes>

  <completion-checklist>
    <item>Extended Baileys mock with message capture (getMockMessages, clearMockMessages)</item>
    <item>Created time-helpers.ts with setupMockTime, advanceTime, resetClock</item>
    <item>Created engagement-fixtures.ts with createMockEngagementState, createMockMessageQueue, createMockTierProgress</item>
    <item>Created idempotency-helpers.ts with runSchedulerTwice, assertNoNewMessages, seed/cleanup helpers</item>
    <item>Created example.test.ts that uses all new utilities</item>
    <item>Verified jest.config.js configuration is correct (likely no changes needed)</item>
    <item>Verified __tests__/setup.ts is correct (likely no changes needed)</item>
    <item>Added JSDoc comments to all public functions with usage examples</item>
    <item>Ran npm test and verified no import errors</item>
    <item>Ran example.test.ts and verified it passes</item>
    <item>All acceptance criteria validated and passing</item>
  </completion-checklist>

  <references>
    <reference type="epic-tech-spec">docs/sprint-artifacts/tech-spec-epic-7.md</reference>
    <reference type="existing-types">whatsapp-bot/src/services/engagement/types.ts</reference>
    <reference type="existing-test-patterns">whatsapp-bot/src/__tests__/utils/test-helpers.ts</reference>
    <reference type="existing-mock">whatsapp-bot/src/__mocks__/baileys.ts</reference>
    <reference type="project-instructions">CLAUDE.md</reference>
  </references>
</story-context>
