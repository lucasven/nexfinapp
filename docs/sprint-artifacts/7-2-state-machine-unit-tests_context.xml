<?xml version="1.0" encoding="UTF-8"?>
<story-context>
  <metadata>
    <story-id>7-2</story-id>
    <story-title>State Machine Unit Tests</story-title>
    <epic>7 - E2E Testing & Quality Assurance</epic>
    <status>ready-for-dev</status>
    <created>2025-11-24</created>
    <related-stories>7.1 (E2E Testing Framework Setup)</related-stories>
  </metadata>

  <overview>
    <summary>
      Comprehensive unit tests for the engagement state machine service
      (whatsapp-bot/src/services/engagement/state-machine.ts) covering all
      state transitions, side effects, analytics, and error handling.
    </summary>
    <scope>
      - All 10 valid state transitions per TRANSITION_MAP
      - Invalid transition rejection with error logging
      - Transition metadata building (days_inactive, response_type, unprompted_return, trigger_source)
      - Database operations (optimistic locking, concurrent safety)
      - Side effects (message queueing, analytics firing)
      - State initialization for new users
      - Activity timestamp management
      - Goodbye message handling with timeouts
      - Analytics event firing
      - Error handling and edge cases
    </scope>
  </overview>

  <acceptance-criteria>
    <criterion id="AC-7.2.1">
      Given transitionState() is called with valid state+trigger, when transition is in TRANSITION_MAP,
      then new state is persisted, transition is logged, and result.success is true with side effects list.
    </criterion>
    <criterion id="AC-7.2.2">
      Given transitionState() is called with invalid state+trigger, when transition is not in TRANSITION_MAP,
      then state is unchanged, error is logged, and result.success is false with descriptive error message.
    </criterion>
    <criterion id="AC-7.2.3">
      Given transitionState() is called, when transition is to goodbye_sent state,
      then goodbye_sent_at and goodbye_expires_at are set, idempotency key is generated,
      and goodbye message is queued via queueMessage().
    </criterion>
    <criterion id="AC-7.2.4">
      Given transitionState() is called, when transition metadata is built,
      then days_inactive is calculated from lastActivityAt, response_type is set for goodbye triggers,
      unprompted_return is true only for dormant→active with 3+ days inactive, and trigger_source is set.
    </criterion>
    <criterion id="AC-7.2.5">
      Given buildStateUpdateData() is called, when targetState is goodbye_sent,
      then goodbye_sent_at=now and goodbye_expires_at=now + 48 hours are set.
    </criterion>
    <criterion id="AC-7.2.6">
      Given buildStateUpdateData() is called, when targetState is remind_later,
      then remind_at=now + 14 days is set.
    </criterion>
    <criterion id="AC-7.2.7">
      Given buildStateUpdateData() is called, when targetState is active,
      then all engagement timestamps (goodbye_sent_at, goodbye_expires_at, remind_at) are cleared
      and last_activity_at is set to now.
    </criterion>
    <criterion id="AC-7.2.8">
      Given transitionState() is called for new user with user_message trigger,
      when user has no engagement state record, then initializeEngagementState is called,
      state is set to active, and transition result indicates initialization.
    </criterion>
    <criterion id="AC-7.2.9">
      Given transitionState() is called twice concurrently for same user,
      when first transaction completes, then second fails with optimistic lock error (PGRST116)
      and returns success=false.
    </criterion>
    <criterion id="AC-7.2.10">
      Given fireTransitionAnalytics() is called, when metadata contains response_type,
      then engagement_goodbye_response event is fired with response_type and timing info.
    </criterion>
    <criterion id="AC-7.2.11">
      Given fireTransitionAnalytics() is called, when metadata.unprompted_return is true,
      then engagement_unprompted_return event is fired with days_inactive and previous_state.
    </criterion>
    <criterion id="AC-7.2.12">
      Given executeGoodbyeTimeoutSideEffects() is called on goodbye_timeout trigger,
      when transition is to dormant, then NO message is sent (silence by design),
      but timeout analytics event is fired with response_type='timeout'.
    </criterion>
    <criterion id="AC-7.2.13">
      Given getUserTransitionHistory() is called, when user has multiple transitions,
      then transitions are returned newest-first, limited to 50 by default,
      and include all metadata fields for analysis.
    </criterion>
    <criterion id="AC-7.2.14">
      Given getTransitionStats() is called with date range, when transitions exist,
      then returns totalTransitions, transitionsByType, responseTypeDistribution,
      unpromptedReturns count, and averageDaysInactive calculated from metadata.
    </criterion>
  </acceptance-criteria>

  <state-machine-reference>
    <state-definition>
      <state name="active" description="User is actively engaged (default state)" />
      <state name="goodbye_sent" description="Goodbye/self-select message sent, awaiting response (max 48h)" />
      <state name="help_flow" description="User needs help or guidance" />
      <state name="remind_later" description="User requested reminder in 14 days" />
      <state name="dormant" description="User declined self-select or timeout expired" />
    </state-definition>

    <transition-map>
      <transition from="active" trigger="inactivity_14d" to="goodbye_sent">
        <side-effects>
          <effect>Set goodbye_sent_at = now</effect>
          <effect>Set goodbye_expires_at = now + 48 hours</effect>
          <effect>Queue goodbye message with idempotency key</effect>
          <effect>Fire engagement_state_changed analytics event</effect>
        </side-effects>
      </transition>

      <transition from="goodbye_sent" trigger="user_message" to="active">
        <side-effects>
          <effect>Clear all engagement timestamps</effect>
          <effect>Set last_activity_at = now</effect>
          <effect>Fire engagement_state_changed analytics event</effect>
        </side-effects>
      </transition>

      <transition from="goodbye_sent" trigger="goodbye_response_1" to="help_flow">
        <side-effects>
          <effect>Clear goodbye timestamps</effect>
          <effect>Fire engagement_goodbye_response event with response_type='confused'</effect>
        </side-effects>
      </transition>

      <transition from="goodbye_sent" trigger="goodbye_response_2" to="remind_later">
        <side-effects>
          <effect>Set remind_at = now + 14 days</effect>
          <effect>Fire engagement_goodbye_response event with response_type='busy'</effect>
        </side-effects>
      </transition>

      <transition from="goodbye_sent" trigger="goodbye_response_3" to="dormant">
        <side-effects>
          <effect>Clear all engagement timestamps</effect>
          <effect>Fire engagement_goodbye_response event with response_type='all_good'</effect>
        </side-effects>
      </transition>

      <transition from="goodbye_sent" trigger="goodbye_timeout" to="dormant">
        <side-effects>
          <effect>NO message sent (dignified silence by design)</effect>
          <effect>Fire engagement_goodbye_response event with response_type='timeout'</effect>
          <effect>Log timeout with days_since_goodbye and hours_waited metrics</effect>
        </side-effects>
      </transition>

      <transition from="help_flow" trigger="user_message" to="active">
        <side-effects>
          <effect>Clear engagement timestamps</effect>
          <effect>Set last_activity_at = now</effect>
          <effect>Fire engagement_state_changed analytics event</effect>
        </side-effects>
      </transition>

      <transition from="remind_later" trigger="user_message" to="active">
        <side-effects>
          <effect>Clear all engagement timestamps</effect>
          <effect>Set last_activity_at = now</effect>
          <effect>Fire engagement_state_changed analytics event</effect>
          <effect>If dormant→active with 3+ days: fire engagement_unprompted_return event</effect>
        </side-effects>
      </transition>

      <transition from="remind_later" trigger="reminder_due" to="dormant">
        <side-effects>
          <effect>Clear all timestamps</effect>
          <effect>Fire engagement_state_changed analytics event</effect>
        </side-effects>
      </transition>

      <transition from="dormant" trigger="user_message" to="active">
        <side-effects>
          <effect>Set last_activity_at = now</effect>
          <effect>Fire engagement_state_changed analytics event</effect>
          <effect>If inactive 3+ days: fire engagement_unprompted_return event</effect>
        </side-effects>
      </transition>
    </transition-map>

    <invalid-transitions>
      <description>All other state+trigger combinations are invalid</description>
      <examples>
        <example from="active" trigger="goodbye_response_1" />
        <example from="help_flow" trigger="goodbye_timeout" />
        <example from="dormant" trigger="inactivity_14d" />
        <example from="remind_later" trigger="goodbye_response_1" />
      </examples>
    </invalid-transitions>
  </state-machine-reference>

  <database-schema>
    <table name="user_engagement_states">
      <column name="id" type="UUID" primary-key="true" />
      <column name="user_id" type="UUID" unique="true" foreign-key="auth.users" />
      <column name="state" type="TEXT" check="active|goodbye_sent|help_flow|remind_later|dormant" />
      <column name="last_activity_at" type="TIMESTAMPTZ" nullable="false" />
      <column name="goodbye_sent_at" type="TIMESTAMPTZ" nullable="true" />
      <column name="goodbye_expires_at" type="TIMESTAMPTZ" nullable="true" />
      <column name="remind_at" type="TIMESTAMPTZ" nullable="true" />
      <column name="created_at" type="TIMESTAMPTZ" nullable="false" />
      <column name="updated_at" type="TIMESTAMPTZ" nullable="false" />
      <indexes>
        <index name="idx_engagement_state" columns="state" />
        <index name="idx_engagement_last_activity" columns="last_activity_at" />
        <index name="idx_engagement_goodbye_expires" columns="goodbye_expires_at" where="goodbye_expires_at IS NOT NULL" />
        <index name="idx_engagement_remind_at" columns="remind_at" where="remind_at IS NOT NULL" />
      </indexes>
    </table>

    <table name="engagement_state_transitions">
      <column name="id" type="UUID" primary-key="true" />
      <column name="user_id" type="UUID" foreign-key="auth.users" />
      <column name="from_state" type="TEXT" />
      <column name="to_state" type="TEXT" />
      <column name="trigger" type="TEXT" />
      <column name="metadata" type="JSONB" nullable="true" />
      <column name="created_at" type="TIMESTAMPTZ" nullable="false" />
      <indexes>
        <index name="idx_transitions_user" columns="user_id" />
        <index name="idx_transitions_created" columns="created_at" />
      </indexes>
    </table>

    <table name="engagement_message_queue">
      <column name="id" type="UUID" primary-key="true" />
      <column name="user_id" type="UUID" foreign-key="auth.users" />
      <column name="message_type" type="TEXT" check="welcome|tier_unlock|goodbye|weekly_review|reminder|help_restart" />
      <column name="message_key" type="TEXT" />
      <column name="message_params" type="JSONB" nullable="true" />
      <column name="destination" type="TEXT" check="individual|group" />
      <column name="destination_jid" type="TEXT" />
      <column name="scheduled_for" type="TIMESTAMPTZ" />
      <column name="sent_at" type="TIMESTAMPTZ" nullable="true" />
      <column name="status" type="TEXT" check="pending|sent|failed|cancelled" />
      <column name="retry_count" type="INTEGER" />
      <column name="error_message" type="TEXT" nullable="true" />
      <column name="idempotency_key" type="TEXT" unique="true" />
      <column name="created_at" type="TIMESTAMPTZ" />
      <indexes>
        <index name="idx_queue_status" columns="status" where="status = 'pending'" />
        <index name="idx_queue_scheduled" columns="scheduled_for" where="status = 'pending'" />
        <index name="idx_queue_user" columns="user_id" />
      </indexes>
    </table>
  </database-schema>

  <service-implementation>
    <file path="whatsapp-bot/src/services/engagement/state-machine.ts">
      <overview>Main service implementing the 5-state engagement state machine</overview>

      <key-functions>
        <function name="transitionState">
          <signature>
            async transitionState(
              userId: string,
              trigger: TransitionTrigger,
              metadata?: Record&lt;string, unknown&gt;
            ): Promise&lt;TransitionResult&gt;
          </signature>
          <steps>
            <step num="1">Get or create current engagement state (handles new users)</step>
            <step num="2">Validate transition using TRANSITION_MAP.getTransitionTarget()</step>
            <step num="3">Build state-specific update data with timestamps (goodbye_sent_at, remind_at, etc.)</step>
            <step num="4">Build full transition metadata (days_inactive, response_type, unprompted_return, trigger_source)</step>
            <step num="5">Update state with optimistic locking (eq('updated_at', currentState.updatedAt))</step>
            <step num="6">Log transition to engagement_state_transitions table</step>
            <step num="7">Fire PostHog analytics events (never fail transition)</step>
            <step num="8">Execute state-specific side effects</step>
          </steps>
          <error-handling>
            <case condition="User not found + non-user_message trigger">
              Return success=false with error message
            </case>
            <case condition="Invalid transition">
              Log warning, return success=false with error
            </case>
            <case condition="Optimistic lock failure (PGRST116)">
              Return success=false with "State was modified by another process"
            </case>
            <case condition="Transition log insert fails">
              Log error but don't fail (state update already succeeded)
            </case>
            <case condition="Analytics firing fails">
              Log error but don't fail (state update already succeeded)
            </case>
          </error-handling>
        </function>

        <function name="buildStateUpdateData">
          <signature>
            function buildStateUpdateData(
              targetState: EngagementState,
              now: Date
            ): Record&lt;string, string | null&gt;
          </signature>
          <logic>
            <case state="goodbye_sent">
              Set goodbye_sent_at = now
              Set goodbye_expires_at = now + GOODBYE_TIMEOUT_HOURS (48h)
            </case>
            <case state="remind_later">
              Set remind_at = now + REMIND_LATER_DAYS (14 days)
            </case>
            <case state="active">
              Clear goodbye_sent_at = null
              Clear goodbye_expires_at = null
              Clear remind_at = null
              Set last_activity_at = now
            </case>
            <case state="dormant">
              Clear goodbye_sent_at = null
              Clear goodbye_expires_at = null
              Clear remind_at = null
            </case>
            <case state="help_flow">
              No special timestamp handling
            </case>
          </logic>
        </function>

        <function name="buildTransitionMetadata">
          <signature>
            function buildTransitionMetadata(
              trigger: TransitionTrigger,
              fromState: EngagementState,
              userState: UserEngagementState,
              daysInactive: number,
              additionalMetadata?: Record&lt;string, unknown&gt;
            ): TransitionMetadata
          </signature>
          <always-included>
            <field name="days_inactive" value="Calculated from lastActivityAt" />
            <field name="trigger_source" value="'user_message' or 'scheduler'" />
          </always-included>
          <conditional>
            <condition trigger="goodbye_response_* or goodbye_timeout">
              <field name="response_type" value="'confused'|'busy'|'all_good'|'timeout'" />
              <field name="hours_waited" value="Hours since goodbye_sent_at" />
              <field name="days_since_goodbye" value="Days since goodbye_sent_at" />
            </condition>
            <condition fromState="dormant AND trigger="user_message" AND daysInactive >= 3">
              <field name="unprompted_return" value="true" />
            </condition>
          </conditional>
        </function>

        <function name="executeGoodbyeSideEffects">
          <signature>
            async executeGoodbyeSideEffects(userId: string): Promise&lt;string[]&gt;
          </signature>
          <steps>
            <step>Get user's preferred destination via getMessageDestination()</step>
            <step>Fetch user's locale from user_profiles</step>
            <step>Generate idempotency key for the day</step>
            <step>Queue goodbye message with queueMessage()</step>
            <step>Return side effects array for logging</step>
          </steps>
        </function>

        <function name="executeGoodbyeTimeoutSideEffects">
          <signature>
            async executeGoodbyeTimeoutSideEffects(
              userId: string,
              userState: UserEngagementState
            ): Promise&lt;string[]&gt;
          </signature>
          <design>
            NO message is sent (silence is design - dignity, not guilt)
            Only analytics event is fired with response_type='timeout'
          </design>
          <metrics>
            <metric name="days_since_goodbye">Math.floor(hoursWaited / 24)</metric>
            <metric name="hours_waited">Math.floor((now - goodbyeSentAt) / (1000 * 60 * 60))</metric>
          </metrics>
        </function>

        <function name="getUserTransitionHistory">
          <signature>
            async getUserTransitionHistory(
              userId: string,
              limit: number = 50
            ): Promise&lt;StateTransition[]&gt;
          </signature>
          <returns>Array of transitions for user, newest first, up to limit</returns>
          <use-case>Debugging, user journey analysis, support tools</use-case>
        </function>

        <function name="getTransitionStats">
          <signature>
            async getTransitionStats(
              startDate: Date,
              endDate: Date
            ): Promise&lt;TransitionStats&gt;
          </signature>
          <aggregations>
            <stat name="totalTransitions">Count of all transitions in date range</stat>
            <stat name="transitionsByType">Record&lt;trigger, count&gt;</stat>
            <stat name="responseTypeDistribution">Record&lt;response_type, count&gt;</stat>
            <stat name="unpromptedReturns">Count where metadata.unprompted_return = true</stat>
            <stat name="averageDaysInactive">Mean of metadata.days_inactive values</stat>
          </aggregations>
          <use-case>Dashboard analytics, engagement metrics reporting</use-case>
        </function>
      </key-functions>

      <error-codes>
        <code name="PGRST116">Optimistic lock conflict - no rows updated due to stale updated_at</code>
        <code name="23505">Unique constraint violation - user already has engagement state (during init)</code>
      </error-codes>

      <constants-referenced>
        <constant name="GOODBYE_TIMEOUT_HOURS">48 hours for response window</constant>
        <constant name="REMIND_LATER_DAYS">14 days for reminder delay</constant>
        <constant name="TRANSITION_MAP">All 10 valid state transitions</constant>
      </constants-referenced>
    </file>

    <file path="whatsapp-bot/src/services/engagement/types.ts">
      <description>Type definitions and TRANSITION_MAP validation</description>
      <exports>
        <export name="EngagementState">Union type: 'active'|'goodbye_sent'|'help_flow'|'remind_later'|'dormant'</export>
        <export name="TransitionTrigger">Union type: user_message, inactivity_14d, goodbye_response_1/2/3, goodbye_timeout, reminder_due, help_requested, help_resolved</export>
        <export name="TRANSITION_MAP">Record mapping state + trigger to target state</export>
        <export name="VALID_TRANSITIONS">Record mapping state to allowed target states</export>
        <export name="getTransitionTarget">Function returning target state or null</export>
        <export name="isValidTransition">Function validating state-to-state transitions</export>
        <export name="TransitionMetadata">Interface with days_inactive, response_type, unprompted_return, etc.</export>
        <export name="UserEngagementState">Complete state record with all timestamps</export>
      </exports>
    </file>

    <file path="whatsapp-bot/src/services/engagement/analytics.ts">
      <description>Analytics event firing and metadata utilities</description>
      <key-functions>
        <function name="fireTransitionAnalytics">
          <behavior>Fires all applicable events based on trigger and metadata</behavior>
          <events>
            <event name="engagement_state_changed">Always fired</event>
            <event name="engagement_goodbye_response">If response_type is set</event>
            <event name="engagement_unprompted_return">If unprompted_return is true</event>
          </events>
        </function>
        <function name="calculateDaysInactive">
          <returns>Floor of (now - lastActivityAt) / milliseconds per day</returns>
        </function>
        <function name="calculateHoursWaited">
          <returns>Floor of (now - timestamp) / milliseconds per hour</returns>
        </function>
        <function name="getGoodbyeResponseType">
          <maps>goodbye_response_1 → 'confused', goodbye_response_2 → 'busy', goodbye_response_3 → 'all_good', goodbye_timeout → 'timeout'</maps>
        </function>
        <function name="isUnpromptedReturn">
          <condition>trigger === 'user_message' AND fromState === 'dormant' AND daysInactive >= 3</condition>
        </function>
      </key-functions>
    </file>

    <file path="whatsapp-bot/src/services/engagement/constants.ts">
      <exports>
        <constant name="INACTIVITY_THRESHOLD_DAYS" value="14" />
        <constant name="GOODBYE_TIMEOUT_HOURS" value="48" />
        <constant name="REMIND_LATER_DAYS" value="14" />
        <constant name="MAX_MESSAGE_RETRIES" value="3" />
        <constant name="TIER_1/2/3_ACTIONS" value="Array of action names for tier completion" />
        <constant name="UNPROMPTED_RETURN_DAYS_THRESHOLD" value="3" />
      </exports>
    </file>
  </service-implementation>

  <test-infrastructure>
    <provided-from-story-7-1>
      <fixture module="__tests__/engagement/fixtures/engagement-fixtures.ts">
        <factory name="createMockEngagementState">
          <param name="options" type="MockEngagementStateOptions" optional="true" />
          <returns type="UserEngagementState" />
          <defaults>
            <field name="userId">Random UUID</field>
            <field name="state">active</field>
            <field name="lastActivityAt">Current date</field>
            <field name="goodbyeSentAt">null</field>
            <field name="goodbyeExpiresAt">null</field>
            <field name="remindAt">null</field>
          </defaults>
          <usage>Create mock engagement state with optional field overrides</usage>
        </factory>

        <factory name="createMockMessageQueue">
          <param name="options" type="MockMessageQueueOptions" optional="true" />
          <returns type="QueuedMessage" />
          <defaults>
            <field name="userId">Random UUID</field>
            <field name="messageType">goodbye</field>
            <field name="destination">individual</field>
            <field name="status">pending</field>
            <field name="retryCount">0</field>
          </defaults>
          <usage>Create mock queued message for testing queueing</usage>
        </factory>

        <factory name="createBulkMockMessages">
          <param name="count" type="number" />
          <param name="baseOptions" type="MockMessageQueueOptions" optional="true" />
          <returns type="QueuedMessage[]" />
          <usage>Create multiple messages at once for bulk testing</usage>
        </factory>

        <factory name="createMockTierProgress">
          <param name="tier" type="number" />
          <param name="completedActions" type="string[]" />
          <returns type="TierProgress" />
          <usage>Create tier progress objects for re-engagement testing</usage>
        </factory>

        <factory name="createCompleteTierProgress">
          <returns type="TierProgress" with all tiers completed />
          <usage>Create fully completed user for testing experienced user scenarios</usage>
        </factory>
      </fixture>

      <utilities module="__tests__/utils/time-helpers.ts">
        <util name="setupMockTime">
          <param name="startDate" type="Date" optional="true" />
          <behavior>Set up Jest fake timers and set system time</behavior>
          <returns type="Date" the start date that was set />
          <usage>Call in beforeEach() to set up deterministic time</usage>
        </util>

        <util name="advanceTime">
          <param name="days" type="number" />
          <behavior>Advance both Jest timers and system time by N days</behavior>
          <returns type="Date" the new current time />
          <usage>Call within test to simulate time passing</usage>
        </util>

        <util name="mockNow">
          <param name="date" type="Date" />
          <behavior>Set Date.now() to specific time without fake timers</behavior>
          <usage>Use when you only need current time mocked, not timers</usage>
        </util>

        <util name="resetClock">
          <behavior>Restore Jest to use real timers</behavior>
          <usage>Call in afterEach() to clean up time state</usage>
        </util>
      </utilities>

      <utilities module="__tests__/utils/idempotency-helpers.ts">
        <util name="seedEngagementState">
          <param name="state" type="UserEngagementState" />
          <behavior>Insert mock engagement state into test database</behavior>
          <returns type="UserEngagementState" the inserted state />
          <usage>Set up initial state for transition tests</usage>
        </util>

        <util name="getEngagementState">
          <param name="userId" type="string" />
          <behavior>Query test database for user's engagement state</behavior>
          <returns type="UserEngagementState | null" />
          <usage>Assert on state changes in tests</usage>
        </util>

        <util name="getMessagesForUser">
          <param name="userId" type="string" />
          <behavior>Query messages queued for a specific user</behavior>
          <returns type="QueuedMessage[]" />
          <usage>Verify messages were queued by state transitions</usage>
        </util>

        <util name="getMessageQueueCount">
          <behavior>Get total count of messages in queue</behavior>
          <returns type="number" />
          <usage>Verify message queueing side effects</usage>
        </util>

        <util name="cleanupEngagementStates">
          <param name="userIds" type="string[]" />
          <behavior>Delete engagement states and related records for test users</behavior>
          <usage>Call in afterEach() to prevent test pollution</usage>
        </util>

        <util name="runSchedulerTwice">
          <param name="schedulerFn" type="() => Promise&lt;void&gt;" />
          <behavior>Run scheduler twice with same clock state, verify idempotency</behavior>
          <returns>Object with messagesBefore, messagesAfterFirst, messagesAfterSecond counts</returns>
          <usage>Test that schedulers never create duplicate messages</usage>
        </util>

        <util name="assertNoNewMessages">
          <param name="countBefore" type="number" />
          <param name="countAfter" type="number" />
          <behavior>Jest expect() assertion that counts are equal</behavior>
          <usage>After runSchedulerTwice, verify idempotency</usage>
        </util>
      </utilities>

      <mocks module="__mocks__/baileys.ts">
        <mock name="mockBaileysClient">
          <method name="sendMessage" />
          <captures-to>mockMessages array</captures-to>
          <usage>Mock WhatsApp client for message sending</usage>
        </mock>

        <util name="getMockMessages">
          <returns type="Array&lt;{ jid, message }&gt;" />
          <usage>Retrieve captured messages sent during test</usage>
        </util>

        <util name="clearMockMessages">
          <behavior>Reset mockMessages array to empty</behavior>
          <usage>Call in beforeEach() to isolate message captures</usage>
        </util>
      </mocks>

      <mocks module="__mocks__/supabase.ts">
        <mock name="mockSupabaseClient">
          <provides>Chainable query builder for Supabase operations</provides>
          <usage>Mock database operations in tests</usage>
        </mock>

        <util name="mockQuerySuccess">
          <param name="data" type="any" />
          <behavior>Configure mock to return success with given data</behavior>
          <usage>Set up expected database responses</usage>
        </util>

        <util name="mockQueryError">
          <param name="error" type="any" />
          <behavior>Configure mock to return error</behavior>
          <usage>Test error handling paths</usage>
        </util>
      </mocks>
    </provided-from-story-7-1>

    <test-patterns>
      <pattern id="basic-transition-test">
        <name>Test a single valid state transition</name>
        <steps>
          <step>Create mock engagement state with from-state</step>
          <step>Seed it to test database</step>
          <step>Call transitionState(userId, trigger)</step>
          <step>Assert result.success === true</step>
          <step>Assert result.newState === expectedState</step>
          <step>Assert side effects include expected operations</step>
          <step>Query database to verify state persisted</step>
          <step>Query transitions table to verify log created</step>
        </steps>
      </pattern>

      <pattern id="invalid-transition-test">
        <name>Test rejecting invalid state transitions</name>
        <steps>
          <step>Create mock engagement state in some state</step>
          <step>Seed to test database</step>
          <step>Call transitionState() with invalid trigger for that state</step>
          <step>Assert result.success === false</step>
          <step>Assert result.error contains descriptive message</step>
          <step>Assert result.newState === result.previousState (unchanged)</step>
          <step>Query database to verify state unchanged</step>
        </steps>
      </pattern>

      <pattern id="side-effects-test">
        <name>Test state-specific side effects</name>
        <steps>
          <step>Set up mocks for all side effect services</step>
          <step>Create state that triggers specific side effect</step>
          <step>Call transitionState()</step>
          <step>Assert queueMessage was called if moving to goodbye_sent</step>
          <step>Assert analytics events were fired</step>
          <step>Verify correct parameters passed to each side effect</step>
        </steps>
      </pattern>

      <pattern id="metadata-building-test">
        <name>Test transition metadata is built correctly</name>
        <steps>
          <step>Create state with known lastActivityAt</step>
          <step>Advance time by known number of days</step>
          <step>Call transitionState() for transition that uses metadata</step>
          <step>Query transitions table for the log entry</step>
          <step>Assert metadata contains expected fields with correct values</step>
          <step>Verify days_inactive calculation is correct</step>
          <step>Verify response_type is correct for goodbye triggers</step>
          <step>Verify unprompted_return flag is correct</step>
        </steps>
      </pattern>

      <pattern id="optimistic-locking-test">
        <name>Test optimistic locking on concurrent updates</name>
        <steps>
          <step>Create engagement state and seed to database</step>
          <step>Mock database to return PGRST116 error on update</step>
          <step>Call transitionState()</step>
          <step>Assert result.success === false</step>
          <step>Assert error message mentions concurrent modification</step>
        </steps>
      </pattern>

      <pattern id="new-user-initialization-test">
        <name>Test transitionState handles new users</name>
        <steps>
          <step>Call transitionState(newUserId, 'user_message') without creating state first</step>
          <step>Assert initializeEngagementState is called</step>
          <step>Assert result.success === true</step>
          <step>Assert result.newState === 'active'</step>
          <step>Assert sideEffects includes 'initialized_new_user'</step>
          <step>Query database to verify state created</step>
        </steps>
      </pattern>

      <pattern id="goodbye-timeout-test">
        <name>Test goodbye_timeout transition - no message, only analytics</name>
        <steps>
          <step>Create state in goodbye_sent with goodbyeSentAt set</step>
          <step>Advance time past goodbye_expires_at</step>
          <step>Call transitionState(userId, 'goodbye_timeout')</step>
          <step>Assert queueMessage was NOT called</step>
          <step>Assert sideEffects includes 'no_message_sent_by_design'</step>
          <step>Assert analytics event fired with response_type='timeout'</step>
          <step>Verify hours_waited and days_since_goodbye calculated correctly</step>
        </steps>
      </pattern>

      <pattern id="timestamp-management-test">
        <name>Test state-specific timestamp updates</name>
        <steps>
          <step>For each target state, verify correct timestamps are set/cleared</step>
          <step>goodbye_sent: goodbye_sent_at and goodbye_expires_at should be set</step>
          <step>remind_later: remind_at should be set</step>
          <step>active: all timestamps should be cleared, last_activity_at set</step>
          <step>dormant: goodbye timestamps should be cleared</step>
          <step>help_flow: no special timestamp handling</step>
        </steps>
      </pattern>

      <pattern id="error-handling-test">
        <name>Test error handling paths</name>
        <steps>
          <step>Test non-existent user with non-user_message trigger</step>
          <step>Test invalid transition rejection</step>
          <step>Test database update failure</step>
          <step>Test transition log insert failure (but state succeeds)</step>
          <step>Test analytics firing failure (but state succeeds)</step>
          <step>Verify all failures are logged appropriately</step>
          <step>Verify none of these failures make transitionState itself fail when appropriate</step>
        </steps>
      </pattern>

      <pattern id="history-and-stats-test">
        <name>Test transition history and stats queries</name>
        <steps>
          <step>Seed multiple transitions with different triggers and metadata</step>
          <step>Call getUserTransitionHistory() and verify ordering and metadata</step>
          <step>Call getTransitionStats() with date range</step>
          <step>Assert totalTransitions count is correct</step>
          <step>Assert transitionsByType has correct distribution</step>
          <step>Assert responseTypeDistribution includes all response types</step>
          <step>Assert unpromptedReturns count is correct</step>
          <step>Assert averageDaysInactive is correctly calculated</step>
        </steps>
      </pattern>
    </test-patterns>
  </test-infrastructure>

  <critical-test-scenarios>
    <scenario name="14-day inactivity → goodbye">
      <description>
        User is active, then inactive for 14+ days.
        Scheduler triggers inactivity_14d.
        State transitions to goodbye_sent, timestamps set, goodbye message queued.
      </description>
      <test-setup>
        <state>active, lastActivityAt = 14 days ago</state>
      </test-setup>
      <trigger>inactivity_14d</trigger>
      <expected-outcome>
        <state>goodbye_sent</state>
        <timestamps>
          <goodbye_sent_at>now</goodbye_sent_at>
          <goodbye_expires_at>now + 48h</goodbye_expires_at>
        </timestamps>
        <side-effects>
          <effect>goodbye message queued with idempotency key</effect>
          <effect>engagement_state_changed event fired</effect>
        </side-effects>
      </expected-outcome>
    </scenario>

    <scenario name="goodbye → response_3 (I'm still here) → dormant">
      <description>
        User in goodbye_sent state receives response_3 trigger.
        Transitions to dormant state (user chose "I'm still here").
      </description>
      <test-setup>
        <state>goodbye_sent, goodbyeSentAt = 2 hours ago</state>
      </test-setup>
      <trigger>goodbye_response_3</trigger>
      <expected-outcome>
        <state>dormant</state>
        <timestamps>
          <goodbye_sent_at>null</goodbye_sent_at>
          <goodbye_expires_at>null</goodbye_expires_at>
        </timestamps>
        <side-effects>
          <effect>engagement_goodbye_response event with response_type='all_good'</effect>
          <effect>hours_waited calculated correctly (2h in metadata)</effect>
        </side-effects>
      </expected-outcome>
    </scenario>

    <scenario name="goodbye → timeout → dormant (silent)">
      <description>
        User in goodbye_sent state doesn't respond within 48h.
        Scheduler triggers goodbye_timeout.
        State transitions to dormant, NO message sent, only analytics.
      </description>
      <test-setup>
        <state>goodbye_sent, goodbyeExpiresAt = now (or in past)</state>
      </test-setup>
      <trigger>goodbye_timeout</trigger>
      <expected-outcome>
        <state>dormant</state>
        <message-sent>false (silence by design)</message-sent>
        <side-effects>
          <effect>NO message queued (this is critical to verify)</effect>
          <effect>engagement_goodbye_response event with response_type='timeout'</effect>
          <effect>sideEffects includes 'no_message_sent_by_design'</effect>
        </side-effects>
      </expected-outcome>
    </scenario>

    <scenario name="dormant → user_message → active (unprompted return)">
      <description>
        User in dormant state sends message after 3+ days.
        Transitions to active, fires unprompted_return analytics event.
      </description>
      <test-setup>
        <state>dormant, lastActivityAt = 5 days ago</state>
      </test-setup>
      <trigger>user_message</trigger>
      <expected-outcome>
        <state>active</state>
        <metadata>
          <unprompted_return>true</unprompted_return>
          <days_inactive>5</days_inactive>
        </metadata>
        <side-effects>
          <effect>engagement_unprompted_return event fired</effect>
          <effect>engagement_state_changed event fired</effect>
          <effect>sideEffects includes 'reactivated_user'</effect>
        </side-effects>
      </expected-outcome>
    </scenario>

    <scenario name="new user first message">
      <description>
        New user sends first message.
        No engagement state exists yet.
        transitionState should initialize state and keep user active.
      </description>
      <test-setup>
        <user>no engagement state record</user>
      </test-setup>
      <trigger>user_message</trigger>
      <expected-outcome>
        <state>active</state>
        <side-effects>
          <effect>initializeEngagementState called and succeeds</effect>
          <effect>sideEffects includes 'initialized_new_user'</effect>
          <effect>No state transition log created (user started active)</effect>
        </side-effects>
      </expected-outcome>
    </scenario>

    <scenario name="goodbye_response_2 (Remind me later)">
      <description>
        User selects "Remind me later" during goodbye message.
        Transitions to remind_later with remind_at = now + 14 days.
      </description>
      <test-setup>
        <state>goodbye_sent, goodbyeSentAt = 1 hour ago</state>
      </test-setup>
      <trigger>goodbye_response_2</trigger>
      <expected-outcome>
        <state>remind_later</state>
        <timestamps>
          <remind_at>now + 14 days</remind_at>
        </timestamps>
        <side-effects>
          <effect>engagement_goodbye_response event with response_type='busy'</effect>
          <effect>sideEffects includes 'reminder_scheduled'</effect>
        </side-effects>
      </expected-outcome>
    </scenario>

    <scenario name="invalid transition rejection">
      <description>
        Test that invalid state+trigger combinations are properly rejected.
        No state change, error logged, success=false returned.
      </description>
      <test-setup>
        <state>active</state>
      </test-setup>
      <trigger>goodbye_response_1 (invalid from active state)</trigger>
      <expected-outcome>
        <state>active (unchanged)</state>
        <result>
          <success>false</success>
          <error>contains "Invalid transition"</error>
        </result>
        <side-effects>
          <effect>warning logged with details</effect>
          <effect>no database updates</effect>
        </side-effects>
      </expected-outcome>
    </scenario>
  </critical-test-scenarios>

  <test-coverage-requirements>
    <requirement category="State Transitions">
      <item>All 10 valid transitions in TRANSITION_MAP (1 test each)</item>
      <item>Invalid transitions from each state (test multiple invalid combinations)</item>
      <item>New user initialization (user_message on non-existent user)</item>
      <item>Non-user_message trigger on non-existent user (should fail)</item>
    </requirement>

    <requirement category="Metadata Building">
      <item>days_inactive calculation with various time differences</item>
      <item>response_type mapping for each goodbye trigger</item>
      <item>unprompted_return flag logic (only dormant→active with 3+ days)</item>
      <item>trigger_source assignment (user_message vs scheduler)</item>
      <item>hours_waited and days_since_goodbye for goodbye timeouts</item>
    </requirement>

    <requirement category="Timestamp Management">
      <item>goodbye_sent_at and goodbye_expires_at setting on goodbye_sent transition</item>
      <item>remind_at calculation on remind_later transition (now + 14 days)</item>
      <item>Timestamp clearing on active/dormant transitions</item>
      <item>last_activity_at update on active transition</item>
      <item>No extra timestamps set for help_flow state</item>
    </requirement>

    <requirement category="Side Effects">
      <item>goodbye message queueing on goodbye_sent transition</item>
      <item>idempotency key generation for goodbye messages</item>
      <item>Message destination routing (individual vs group)</item>
      <item>NO message sent on goodbye_timeout (silence by design)</item>
      <item>Analytics event firing for each transition</item>
      <item>Goodbye response analytics with timing</item>
      <item>Unprompted return analytics event</item>
    </requirement>

    <requirement category="Database Operations">
      <item>Transition logged to engagement_state_transitions table</item>
      <item>Transition log includes all metadata fields</item>
      <item>Optimistic locking prevents concurrent conflicts</item>
      <item>Optimistic lock failure returns PGRST116 error</item>
      <item>State record updated with new state and timestamps</item>
      <item>updated_at timestamp changes on every transition</item>
    </requirement>

    <requirement category="Error Handling">
      <item>Invalid transitions logged and rejected gracefully</item>
      <item>Missing user errors handled (appropriate for trigger)</item>
      <item>Database errors logged but don't fail state updates</item>
      <item>Transition log failures logged but state update succeeds</item>
      <item>Analytics failures logged but state update succeeds</item>
      <item>Exceptions caught and logged at function level</item>
    </requirement>

    <requirement category="Query Functions">
      <item>getUserTransitionHistory returns transitions newest-first</item>
      <item>getUserTransitionHistory respects limit parameter</item>
      <item>getTransitionStats aggregates correctly over date range</item>
      <item>transitionsByType counts distributions</item>
      <item>responseTypeDistribution counts goodbye responses</item>
      <item>unpromptedReturns counts correctly</item>
      <item>averageDaysInactive calculated correctly</item>
    </requirement>

    <requirement category="Edge Cases">
      <item>User with no lastActivityAt (null handling)</item>
      <item>Transition with null metadata</item>
      <item>Goodbye expires_at in past (timeout already due)</item>
      <item>Days inactive calculation for same-day activity</item>
      <item>Response type for goodbye_timeout</item>
      <item>Multiple transitions in quick succession</item>
    </requirement>

    <requirement category="Integration">
      <item>Full state machine flow: active → goodbye_sent → dormant</item>
      <item>Full state machine flow: active → goodbye_sent → remind_later → dormant</item>
      <item>Full state machine flow: active → goodbye_sent → help_flow → active</item>
      <item>Dormant → active with unprompted return analytics</item>
      <item>All side effects execute without blocking each other</item>
    </requirement>
  </test-coverage-requirements>

  <mocking-strategy>
    <mock-component name="Supabase Client">
      <strategy>Use __mocks__/supabase.ts provided from Story 7.1</strategy>
      <mock-methods>
        <method name="select">Mock to return chainable query builder</method>
        <method name="insert">Mock to return response with inserted data</method>
        <method name="update">Mock to return response with updated data</method>
        <method name="delete">Mock to return response</method>
        <method name="eq">Mock to return chainable query builder</method>
        <method name="single">Mock to return single row or error</method>
        <method name="select(*, { count: 'exact', head: true })">Mock to return count</method>
      </mock-methods>
      <error-simulation>
        <error code="PGRST116">Optimistic lock failure - no rows updated</error>
        <error code="23505">Unique constraint violation</error>
      </error-simulation>
    </mock-component>

    <mock-component name="Analytics/Tracker">
      <strategy>Jest mock at module level</strategy>
      <mock-functions>
        <func name="trackEvent">Mock to capture event calls</func>
        <func name="fireStateChangedEvent">Mock to capture calls</func>
        <func name="fireGoodbyeResponseEvent">Mock to capture calls</func>
        <func name="fireUnpromptedReturnEvent">Mock to capture calls</func>
      </mock-functions>
      <assertions>
        <assertion>Verify trackEvent called with correct event type</assertion>
        <assertion>Verify correct properties passed to events</assertion>
        <assertion>Verify event fired or not fired based on trigger</assertion>
      </assertions>
    </mock-component>

    <mock-component name="Message Sender (queueMessage)">
      <strategy>Jest mock at module level</strategy>
      <mock-function name="queueMessage">
        <param name="params" />
        <returns>Promise&lt;boolean&gt;</returns>
        <default-behavior>return true (success)</default-behavior>
      </mock-function>
      <assertions>
        <assertion>Verify queueMessage called with correct userId and messageType</assertion>
        <assertion>Verify idempotency key format correct</assertion>
        <assertion>Verify message destination routed correctly</assertion>
        <assertion>Verify NOT called on goodbye_timeout</assertion>
      </assertions>
    </mock-component>

    <mock-component name="Message Destination Routing">
      <strategy>Jest mock at module level</strategy>
      <mock-function name="getMessageDestination">
        <param name="userId" />
        <returns>Promise&lt;RouteResult | null&gt;</returns>
        <default-behavior>return { destination: 'individual', destinationJid: userId@s.whatsapp.net, fallbackUsed: false }</default-behavior>
      </mock-function>
    </mock-component>

    <mock-component name="Logger">
      <strategy>Jest mock to avoid console spam in tests</strategy>
      <mock-functions>
        <func name="logger.info">Mock to capture log calls</func>
        <func name="logger.warn">Mock to capture warnings</func>
        <func name="logger.error">Mock to capture errors</func>
        <func name="logger.debug">Mock to capture debug logs</func>
      </mock-functions>
      <usage>Verify correct logging for transitions and errors</usage>
    </mock-component>

    <mock-component name="Date/Time">
      <strategy>Use setupMockTime() from Story 7.1 time-helpers</strategy>
      <behavior>Control Date.now() and setInterval/setTimeout</behavior>
      <usage>Make timestamp calculations deterministic</usage>
    </mock-component>
  </mocking-strategy>

  <test-file-structure>
    <file path="whatsapp-bot/src/__tests__/services/engagement/state-machine.test.ts">
      <purpose>Comprehensive unit tests for state-machine.ts</purpose>
      <structure>
        <suite name="transitionState()">
          <suite name="Valid Transitions">
            <test name="should transition active → goodbye_sent on inactivity_14d" />
            <test name="should transition goodbye_sent → active on user_message" />
            <test name="should transition goodbye_sent → help_flow on goodbye_response_1" />
            <test name="should transition goodbye_sent → remind_later on goodbye_response_2" />
            <test name="should transition goodbye_sent → dormant on goodbye_response_3" />
            <test name="should transition goodbye_sent → dormant on goodbye_timeout" />
            <test name="should transition help_flow → active on user_message" />
            <test name="should transition remind_later → active on user_message" />
            <test name="should transition remind_later → dormant on reminder_due" />
            <test name="should transition dormant → active on user_message" />
          </suite>

          <suite name="Invalid Transitions">
            <test name="should reject invalid transitions with error" />
            <test name="should log warning for invalid transition" />
            <test name="should not update state for invalid transition" />
            <test name="should not create transition log for invalid transition" />
          </suite>

          <suite name="New User Initialization">
            <test name="should initialize new user on user_message" />
            <test name="should not initialize new user on non-user_message trigger" />
            <test name="should handle race condition during initialization" />
          </suite>

          <suite name="Side Effects">
            <test name="should queue goodbye message on goodbye_sent transition" />
            <test name="should not queue message on goodbye_timeout" />
            <test name="should generate idempotency key for goodbye" />
            <test name="should route message to correct destination" />
            <test name="should fire analytics events" />
            <test name="should include side effects in result" />
          </suite>

          <suite name="Concurrency & Locking">
            <test name="should handle optimistic lock conflict (PGRST116)" />
            <test name="should return error on concurrent modification" />
          </suite>

          <suite name="Error Handling">
            <test name="should log error for transition log insert failure" />
            <test name="should not fail transition if log insert fails" />
            <test name="should log error for analytics failure" />
            <test name="should not fail transition if analytics fails" />
            <test name="should catch unexpected exceptions" />
          </suite>
        </suite>

        <suite name="buildStateUpdateData()">
          <test name="should set goodbye timestamps for goodbye_sent" />
          <test name="should set remind_at for remind_later" />
          <test name="should clear timestamps for active" />
          <test name="should clear goodbye timestamps for dormant" />
          <test name="should not set timestamps for help_flow" />
          <test name="should calculate goodbye_expires_at correctly (now + 48h)" />
          <test name="should calculate remind_at correctly (now + 14 days)" />
        </suite>

        <suite name="buildTransitionMetadata()">
          <test name="should calculate days_inactive correctly" />
          <test name="should set response_type for goodbye triggers" />
          <test name="should set unprompted_return for dormant→active with 3+ days" />
          <test name="should not set unprompted_return for other transitions" />
          <test name="should set trigger_source to user_message or scheduler" />
          <test name="should calculate hours_waited for goodbye triggers" />
          <test name="should calculate days_since_goodbye for goodbye triggers" />
          <test name="should include additional metadata from parameter" />
        </suite>

        <suite name="executeGoodbyeSideEffects()">
          <test name="should get message destination" />
          <test name="should fetch user locale" />
          <test name="should generate idempotency key" />
          <test name="should queue message with correct parameters" />
          <test name="should log success if message queued" />
          <test name="should log warning if no destination found" />
        </suite>

        <suite name="executeGoodbyeTimeoutSideEffects()">
          <test name="should NOT queue message (silent by design)" />
          <test name="should fire goodbye_response analytics event" />
          <test name="should calculate hours_waited correctly" />
          <test name="should calculate days_since_goodbye correctly" />
          <test name="should include 'no_message_sent_by_design' in side effects" />
        </suite>

        <suite name="getEngagementState()">
          <test name="should return active state for new user without record" />
          <test name="should return user's current state" />
        </suite>

        <suite name="getEngagementStateRecord()">
          <test name="should return full state record with all timestamps" />
          <test name="should return null for non-existent user" />
        </suite>

        <suite name="initializeEngagementState()">
          <test name="should create state with state=active" />
          <test name="should set last_activity_at to now" />
          <test name="should handle unique constraint (user already initialized)" />
          <test name="should log info on initialization" />
        </suite>

        <suite name="updateLastActivity()">
          <test name="should update last_activity_at timestamp" />
          <test name="should return true on success" />
          <test name="should return false on error" />
        </suite>

        <suite name="getInactiveUsers()">
          <test name="should return users in active state with lastActivityAt before threshold" />
          <test name="should not return users in other states" />
          <test name="should not return recently active users" />
        </suite>

        <suite name="getExpiredGoodbyes()">
          <test name="should return users in goodbye_sent state with expired goodbye_expires_at" />
          <test name="should not return users with future expiry" />
        </suite>

        <suite name="getDueReminders()">
          <test name="should return users in remind_later state with remind_at in past" />
          <test name="should not return users with future reminder" />
        </suite>

        <suite name="getUserTransitionHistory()">
          <test name="should return transitions for user, newest first" />
          <test name="should respect limit parameter" />
          <test name="should include all metadata" />
          <test name="should return empty array for user with no transitions" />
        </suite>

        <suite name="getTransitionStats()">
          <test name="should count total transitions in date range" />
          <test name="should distribute transitions by trigger type" />
          <test name="should count response type distribution" />
          <test name="should count unprompted returns" />
          <test name="should calculate average days inactive" />
          <test name="should return default stats for date range with no transitions" />
        </suite>
      </structure>
    </file>

    <file path="whatsapp-bot/src/__tests__/services/engagement/analytics.test.ts">
      <purpose>Unit tests for analytics helper functions</purpose>
      <suite name="calculateDaysInactive()">
        <test name="should calculate days difference" />
        <test name="should return 0 for null lastActivityAt" />
        <test name="should handle edge case of same-day timestamp" />
      </suite>

      <suite name="calculateHoursWaited()">
        <test name="should calculate hours difference" />
        <test name="should return 0 for null timestamp" />
      </suite>

      <suite name="getGoodbyeResponseType()">
        <test name="should map goodbye_response_1 → confused" />
        <test name="should map goodbye_response_2 → busy" />
        <test name="should map goodbye_response_3 → all_good" />
        <test name="should map goodbye_timeout → timeout" />
        <test name="should return undefined for non-goodbye trigger" />
      </suite>

      <suite name="isUnpromptedReturn()">
        <test name="should return true for dormant→active with 3+ days" />
        <test name="should return false for dormant→active with <3 days" />
        <test name="should return false for non-user_message trigger" />
        <test name="should return false for non-dormant state" />
      </suite>

      <suite name="fireTransitionAnalytics()">
        <test name="should fire engagement_state_changed event" />
        <test name="should fire engagement_goodbye_response for goodbye triggers" />
        <test name="should fire engagement_unprompted_return for unprompted returns" />
        <test name="should not fail if event firing fails" />
      </suite>
    </file>
  </test-file-structure>

  <key-test-assertions>
    <assertion category="State Changes">
      <check>result.newState === expectedState</check>
      <check>result.previousState === previousState</check>
      <check>db query shows state persisted correctly</check>
    </assertion>

    <assertion category="Success/Failure">
      <check>result.success === true/false as expected</check>
      <check>result.error contains descriptive message for failures</check>
      <check>result.transitionId exists for successful transitions</check>
    </assertion>

    <assertion category="Side Effects">
      <check>result.sideEffects array contains expected operations</check>
      <check>queueMessage called with correct parameters when expected</check>
      <check>queueMessage NOT called on goodbye_timeout</check>
      <check>analytics events fired with correct parameters</check>
      <check>state transitions logged to engagement_state_transitions table</check>
    </assertion>

    <assertion category="Timestamps">
      <check>goodbye_sent_at set correctly for goodbye_sent state</check>
      <check>goodbye_expires_at = goodbye_sent_at + 48 hours</check>
      <check>remind_at = now + 14 days for remind_later state</check>
      <check>last_activity_at updated when transitioning to active</check>
      <check>All timestamps cleared when appropriate</check>
    </assertion>

    <assertion category="Metadata">
      <check>days_inactive calculated from lastActivityAt</check>
      <check>response_type set for goodbye triggers only</check>
      <check>unprompted_return true only for dormant→active with 3+ days</check>
      <check>trigger_source is 'user_message' or 'scheduler'</check>
      <check>hours_waited and days_since_goodbye for goodbye responses</check>
    </assertion>

    <assertion category="Error Handling">
      <check>Invalid transitions return success=false</check>
      <check>Invalid transitions don't create logs</check>
      <check>Database errors logged but don't break transition</check>
      <check>Analytics errors logged but don't break transition</check>
      <check>Exception handling catches and logs unexpected errors</check>
    </assertion>

    <assertion category="Concurrency">
      <check>Optimistic lock failure returns PGRST116 error code</check>
      <check>Optimistic lock failure returns success=false</check>
      <check>Error message indicates concurrent modification</check>
    </assertion>
  </key-test-assertions>

  <notes-for-developer>
    <note priority="high">
      The state machine service is the CORE of the engagement system. These tests are critical
      for ensuring reliability. Aim for 100% code coverage, especially critical paths.
    </note>

    <note priority="high">
      The goodbye_timeout transition is special: NO MESSAGE is sent. This is a deliberate design
      choice (dignified silence). Make sure tests explicitly verify that queueMessage is NOT called.
      Do not treat this as a missing feature.
    </note>

    <note priority="high">
      Optimistic locking (optimistic concurrency control via updated_at) is critical for
      preventing race conditions. Test this thoroughly with concurrent update scenarios.
    </note>

    <note priority="high">
      Side effects (message queueing, analytics) should NEVER cause transitionState to fail.
      Errors in side effects should be logged but the transition should succeed.
      This is critical for data consistency.
    </note>

    <note priority="medium">
      Time-based calculations (days_inactive, hours_waited) need careful testing with various
      time gaps. Use setupMockTime() and advanceTime() from Story 7.1 utilities.
    </note>

    <note priority="medium">
      The unprompted_return flag logic is specific: ONLY dormant→active with user_message
      trigger and 3+ days inactive. Test boundary cases (2 days, 3 days, 4 days).
    </note>

    <note priority="medium">
      New user initialization can race with external processes. Test the unique constraint
      violation (23505) scenario and verify recovery path works.
    </note>

    <note priority="low">
      Query helper functions (getUserTransitionHistory, getTransitionStats) are important
      for analytics and debugging but less critical than core transitions. Test them but
      don't spend excessive time here.
    </note>

    <note priority="low">
      Consider property-based testing for state transition validation: for any valid transition,
      verify the result is success=true and side effects execute. Use jest-quickcheck or similar.
    </note>

    <note priority="general">
      Reference the example test (whatsapp-bot/src/__tests__/engagement/example.test.ts)
      created in Story 7.1. Follow its patterns for test structure and setup/teardown.
    </note>

    <note priority="general">
      Keep tests isolated: each test should be independent. Use randomUUID() for test users
      and cleanupEngagementStates() in afterEach() to prevent test pollution.
    </note>

    <note priority="general">
      Use fixtures from Story 7.1 (createMockEngagementState, createMockMessageQueue) to
      keep tests concise and readable. Don't hardcode test data.
    </note>
  </notes-for-developer>

  <references>
    <reference type="source-file" path="whatsapp-bot/src/services/engagement/state-machine.ts">
      Main service implementation with full AC-4.1 through AC-4.7 implementation
    </reference>
    <reference type="source-file" path="whatsapp-bot/src/services/engagement/types.ts">
      Type definitions including TRANSITION_MAP and EngagementState union type
    </reference>
    <reference type="source-file" path="whatsapp-bot/src/services/engagement/constants.ts">
      Constants including GOODBYE_TIMEOUT_HOURS, REMIND_LATER_DAYS, etc.
    </reference>
    <reference type="source-file" path="whatsapp-bot/src/services/engagement/analytics.ts">
      Analytics helper functions for transition metadata and event firing
    </reference>
    <reference type="schema" path="fe/scripts/034_engagement_system.sql">
      Database tables: user_engagement_states, engagement_state_transitions, engagement_message_queue
    </reference>
    <reference type="test-infrastructure" path="whatsapp-bot/src/__tests__/engagement/fixtures/engagement-fixtures.ts">
      Test fixtures from Story 7.1
    </reference>
    <reference type="test-infrastructure" path="whatsapp-bot/src/__tests__/utils/time-helpers.ts">
      Time manipulation utilities from Story 7.1
    </reference>
    <reference type="test-infrastructure" path="whatsapp-bot/src/__tests__/utils/idempotency-helpers.ts">
      Database helper utilities from Story 7.1
    </reference>
    <reference type="documentation" path="docs/sprint-artifacts/7-1-e2e-testing-framework-setup.md">
      Story 7.1 documentation with testing infrastructure details
    </reference>
    <reference type="documentation" path="CLAUDE.md#Testing-Strategy">
      Project-wide testing strategy and best practices
    </reference>
  </references>
</story-context>
