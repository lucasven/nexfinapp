<?xml version="1.0" encoding="UTF-8"?>
<story-context>
  <metadata>
    <story-id>5-3-weekly-review-job-message</story-id>
    <story-title>Weekly Review Job &amp; Message</story-title>
    <epic>5 - Scheduled Jobs &amp; Weekly Reviews</epic>
    <status>ready-for-dev</status>
    <generated-date>2025-11-24</generated-date>
  </metadata>

  <story-description>
    <user-story>
      As a active user,
      I want to receive a weekly celebratory message acknowledging my financial tracking activity,
      So that I feel encouraged to continue using the app and see my progress recognized.
    </user-story>

    <acceptance-criteria>
      <criterion id="AC-5.3.1">
        Given the weekly job runs at 9 AM UTC Monday, when evaluating active users, then users with activity last week receive a `weekly_review` message queued to their preferred destination.
      </criterion>
      <criterion id="AC-5.3.2">
        Given a user had NO activity last week, when the weekly job runs, then NO message is sent to that user.
      </criterion>
      <criterion id="AC-5.3.3">
        Given the weekly job runs twice in the same week, when processing the same user, then only ONE weekly review message exists (idempotency via `{userId}:weekly_review:{YYYY-Www}` key).
      </criterion>
    </acceptance-criteria>
  </story-description>

  <technical-context>
    <dependencies>
      <dependency type="service" status="done">
        <name>Activity Detector Service</name>
        <location>whatsapp-bot/src/services/scheduler/activity-detector.ts</location>
        <story-ref>Story 5.2</story-ref>
        <interface>
          <function>
            <signature>getActiveUsersLastWeek(): Promise&lt;ActiveUser[]&gt;</signature>
            <returns>Array of users with activity in last 7 days (transactions OR bot interactions)</returns>
            <filters>Excludes dormant and opted-out users</filters>
          </function>
          <type>
            <name>ActiveUser</name>
            <fields>
              <field>userId: string</field>
              <field>transactionCount: number</field>
              <field>lastActivityAt: Date</field>
              <field>preferredDestination: 'individual' | 'group'</field>
              <field>destinationJid: string</field>
              <field>locale: string</field>
            </fields>
          </type>
        </interface>
      </dependency>

      <dependency type="service" status="available">
        <name>Message Queue Service</name>
        <location>whatsapp-bot/src/services/scheduler/message-sender.ts</location>
        <story-ref>Story 1.6 (Foundation), Story 4.6 (Routing)</story-ref>
        <interface>
          <function>
            <signature>queueMessage(params: QueueMessageParams): Promise&lt;boolean&gt;</signature>
            <params>
              <param>userId: string</param>
              <param>messageType: MessageType (use 'weekly_review')</param>
              <param>messageKey: string (use 'engagement.weekly_review.celebration')</param>
              <param>messageParams?: Record&lt;string, unknown&gt; (use { count: number })</param>
              <param>destination: 'individual' | 'group'</param>
              <param>destinationJid: string</param>
              <param>scheduledFor?: Date (optional, defaults to now)</param>
            </params>
            <returns>boolean - true if queued successfully, false on error</returns>
            <behavior>
              - Generates internal idempotency key: {userId}:{messageType}:{YYYY-MM-DD}
              - Uses upsert with ignoreDuplicates: true
              - Does NOT throw on duplicate - returns true (silent idempotency)
            </behavior>
          </function>
        </interface>
        <note type="important">
          Current implementation generates idempotency key internally using DAILY format (YYYY-MM-DD).
          Story 5.3 requires WEEKLY format (YYYY-Www) per AC-5.3.3.

          OPTIONS:
          1. Modify queueMessage to accept optional idempotencyKey parameter
          2. Use different messageType per week (e.g., 'weekly_review_2025_W47')
          3. Accept daily format limitation (allow multiple messages per week)

          RECOMMENDATION: Modify QueueMessageParams interface to accept optional idempotencyKey.
          This maintains backward compatibility while enabling weekly idempotency.
        </note>
      </dependency>

      <dependency type="database" status="done">
        <name>PostgreSQL function: get_active_users_last_week</name>
        <location>fe/scripts/036_get_active_users_function.sql</location>
        <story-ref>Story 5.2</story-ref>
        <usage>Called by activity-detector.ts via Supabase RPC</usage>
      </dependency>

      <dependency type="library" status="available">
        <name>date-fns</name>
        <functions>
          <function>getISOWeek(date: Date): number</function>
          <function>getISOWeekYear(date: Date): number</function>
        </functions>
        <purpose>Generate ISO week format for idempotency keys (YYYY-Www)</purpose>
      </dependency>
    </dependencies>

    <existing-patterns>
      <pattern name="Job Service Pattern">
        <reference>whatsapp-bot/src/services/scheduler/daily-engagement-job.ts</reference>
        <description>
          - Export async function returning JobResult
          - JobResult interface with processed/succeeded/failed/skipped/errors/durationMs
          - Structured logging at start/completion with duration
          - Try-catch per user for failure isolation
          - Track counts and errors array
        </description>
      </pattern>

      <pattern name="Cron Entry Point Pattern">
        <reference>whatsapp-bot/src/cron/run-engagement-daily.ts</reference>
        <description>
          - Import job function from service
          - async main() with try-catch
          - Log results with structured data
          - Exit code 0 on success, non-zero on failure
          - Initialize Supabase client before job
        </description>
      </pattern>

      <pattern name="Localization Message Pattern">
        <reference>whatsapp-bot/src/localization/pt-br.ts:397</reference>
        <existing-key>engagementWeeklyReviewActive</existing-key>
        <description>
          Weekly review messages already exist but use old signature with summary object.
          Need to add new keys: engagement.weekly_review.celebration
        </description>
      </pattern>

      <pattern name="Import Paths">
        <convention>ESM with .js extensions</convention>
        <examples>
          <example>import { getSupabaseClient } from '../database/supabase-client.js'</example>
          <example>import { logger } from '../monitoring/logger.js'</example>
        </examples>
      </pattern>
    </existing-patterns>

    <implementation-notes>
      <note priority="critical">
        <title>Idempotency Key Format Mismatch</title>
        <detail>
          ISSUE: message-sender.ts queueMessage() generates idempotency keys internally using DAILY format:
          {userId}:{messageType}:{YYYY-MM-DD}

          Story 5.3 requires WEEKLY format per AC-5.3.3:
          {userId}:weekly_review:{YYYY-Www}

          SOLUTION: Modify QueueMessageParams interface to accept optional idempotencyKey parameter.

          Implementation steps:
          1. Add optional field to QueueMessageParams interface:
             idempotencyKey?: string

          2. Modify queueMessage() function (line 65-131):
             - Check if params.idempotencyKey is provided
             - If yes: use params.idempotencyKey
             - If no: generate default key (backward compatible)

          3. Update code:
             const idempotencyKey = params.idempotencyKey || getIdempotencyKey(
               params.userId,
               params.messageType,
               params.scheduledFor || new Date()
             )

          This maintains backward compatibility while enabling custom idempotency keys for weekly reviews.
        </detail>
      </note>

      <note priority="high">
        <title>ISO Week Format for Idempotency</title>
        <detail>
          Use date-fns functions getISOWeek() and getISOWeekYear() to generate consistent week keys.
          Format: {userId}:weekly_review:{YYYY}-W{ww}
          Example: "abc123:weekly_review:2025-W47"

          This ensures:
          - Weeks start on Monday, end on Sunday
          - Week 1 is the week with first Thursday of year
          - All runs within same week generate same key

          IDEMPOTENCY BEHAVIOR (AC-5.3.3):
          - queueMessage uses upsert with ignoreDuplicates: true
          - Duplicate key silently ignored (returns true, no error thrown)
          - Job cannot distinguish between "newly queued" vs "already queued"
          - This is acceptable: both cases mean "message will be sent exactly once this week"
          - No need to track "skipped" count for duplicates in this story
        </detail>
      </note>

      <note priority="high">
        <title>Celebratory Tone vs Existing Weekly Review</title>
        <detail>
          Existing localization keys (engagementWeeklyReviewActive) use different signature.
          Story 5.3 requires simpler message: just transaction count.

          Add NEW keys:
          - pt-br: engagement.weekly_review.celebration
          - en: engagement.weekly_review.celebration

          Format: "ParabÃ©ns! ðŸŽ‰ VocÃª registrou {{count}} transaÃ§Ãµes esta semana. Continue assim!"
        </detail>
      </note>

      <note priority="medium">
        <title>No State Machine Involvement</title>
        <detail>
          Unlike Story 5.1 (Daily Engagement Job), the weekly review job is purely celebratory.
          It sends messages but does NOT change engagement states.
          Do NOT import or use state-machine.ts in this story.
        </detail>
      </note>

      <note priority="medium">
        <title>Performance Target</title>
        <detail>
          Job must complete in &lt; 60 seconds for 10,000 users (per NFR3).
          Strategy:
          - Single aggregated query via getActiveUsersLastWeek()
          - No N+1 queries
          - Message queueing is single INSERT per user
          - PostHog events are fire-and-forget (non-blocking)
        </detail>
      </note>

      <note priority="medium">
        <title>Railway Cron Schedule</title>
        <detail>
          Schedule: "0 9 * * 1" (9 AM UTC Monday)
          Command: "tsx src/cron/run-engagement-weekly.ts"
          Add to whatsapp-bot/railway.cron.yml
        </detail>
      </note>
    </implementation-notes>

    <file-locations>
      <new-files>
        <file>whatsapp-bot/src/services/scheduler/weekly-review-job.ts</file>
        <file>whatsapp-bot/src/cron/run-engagement-weekly.ts</file>
        <file>whatsapp-bot/src/__tests__/scheduler/weekly-review-job.test.ts</file>
      </new-files>

      <modified-files>
        <file>whatsapp-bot/src/localization/pt-br.ts (add engagement.weekly_review.celebration)</file>
        <file>whatsapp-bot/src/localization/en.ts (add engagement.weekly_review.celebration)</file>
        <file>whatsapp-bot/railway.cron.yml (add engagement-weekly job)</file>
        <file>docs/sprint-artifacts/sprint-status.yaml (update story status)</file>
        <file>docs/sprint-artifacts/5-3-weekly-review-job-message.md (mark tasks complete)</file>
      </modified-files>

      <potentially-created-files>
        <file>whatsapp-bot/src/services/scheduler/message-sender.ts (if doesn't exist - Story 5.4 dependency)</file>
      </potentially-created-files>
    </file-locations>
  </technical-context>

  <code-examples>
    <example language="typescript" file="weekly-review-job.ts">
      <description>Service implementation following daily-engagement-job.ts pattern</description>
      <code><![CDATA[
/**
 * Weekly Review Job
 *
 * Scheduled job that runs once weekly (Monday 9 AM UTC) to:
 * - Detect active users (7 days with transactions OR bot activity)
 * - Send celebratory messages acknowledging their financial tracking
 *
 * Epic: 5 - Scheduled Jobs & Weekly Reviews
 * Story: 5.3 - Weekly Review Job & Message
 *
 * AC-5.3.1: Active users receive weekly_review message to preferred destination
 * AC-5.3.2: Users with no activity receive NO message
 * AC-5.3.3: Idempotency via {userId}:weekly_review:{YYYY-Www} key
 */

import { logger } from '../monitoring/logger.js'
import { getActiveUsersLastWeek } from './activity-detector.js'
import { queueMessage } from './message-sender.js'
import { getISOWeek, getISOWeekYear } from 'date-fns'
// PostHog client import (check existing pattern)

export interface JobResult {
  processed: number
  succeeded: number
  failed: number
  skipped: number
  errors: Array<{ userId: string; error: string }>
  durationMs: number
}

export async function runWeeklyReviewJob(): Promise<JobResult> {
  const startTime = Date.now()
  const result: JobResult = {
    processed: 0,
    succeeded: 0,
    failed: 0,
    skipped: 0,
    errors: [],
    durationMs: 0
  }

  logger.info('Weekly review job started', {
    started_at: new Date().toISOString()
  })

  try {
    // Step 1: Get active users from last week (AC-5.3.1, AC-5.3.2)
    const activeUsers = await getActiveUsersLastWeek()

    logger.info('Active users detected for weekly review', {
      count: activeUsers.length
    })

    // Step 2: Process each active user
    for (const user of activeUsers) {
      result.processed++

      try {
        // Generate idempotency key using ISO week (AC-5.3.3)
        const now = new Date()
        const weekYear = getISOWeekYear(now)
        const weekNumber = getISOWeek(now)
        const idempotencyKey = `${user.userId}:weekly_review:${weekYear}-W${weekNumber.toString().padStart(2, '0')}`

        // Queue weekly review message
        const queued = await queueMessage({
          userId: user.userId,
          messageType: 'weekly_review',
          messageKey: 'engagement.weekly_review.celebration',
          messageParams: {
            count: user.transactionCount
          },
          destination: user.preferredDestination,
          destinationJid: user.destinationJid,
          scheduledFor: now,
          idempotencyKey
        })

        if (queued) {
          result.succeeded++
        } else {
          // queueMessage returns false on error (but doesn't throw)
          result.failed++
          result.errors.push({
            userId: user.userId,
            error: 'Failed to queue message (returned false)'
          })
        }

        // Fire PostHog analytics event
        // posthog.capture({ ... })

        logger.debug('Queued weekly review for user', {
          userId: user.userId,
          transactionCount: user.transactionCount
        })
      } catch (error) {
        // Catch any unexpected errors (queueMessage shouldn't throw, but defensive coding)
        result.failed++
        result.errors.push({
          userId: user.userId,
          error: error instanceof Error ? error.message : String(error)
        })
        logger.error('Exception queueing weekly review', {
          userId: user.userId,
          error: error instanceof Error ? error.message : String(error)
        })
      }
    }
  } catch (error) {
    logger.error('Weekly review job failed', {}, error as Error)
    throw error
  } finally {
    result.durationMs = Date.now() - startTime
    logger.info('Weekly review job completed', {
      duration_ms: result.durationMs,
      processed: result.processed,
      succeeded: result.succeeded,
      failed: result.failed,
      skipped: result.skipped
    })
  }

  return result
}
      ]]></code>
    </example>

    <example language="typescript" file="run-engagement-weekly.ts">
      <description>Cron entry point following run-engagement-daily.ts pattern</description>
      <code><![CDATA[
/**
 * Weekly Engagement Cron Entry Point
 *
 * Executed by Railway cron every Monday at 9 AM UTC
 * Schedule: "0 9 * * 1"
 *
 * Story: 5.3 - Weekly Review Job & Message
 */

import { runWeeklyReviewJob } from '../services/scheduler/weekly-review-job.js'
import { logger } from '../monitoring/logger.js'

async function main() {
  try {
    logger.info('Starting weekly engagement cron job')

    const result = await runWeeklyReviewJob()

    logger.info('Weekly review job completed successfully', {
      processed: result.processed,
      succeeded: result.succeeded,
      failed: result.failed,
      skipped: result.skipped,
      duration_ms: result.durationMs
    })

    if (result.failed > 0) {
      logger.warn('Some users failed to process', {
        failed_count: result.failed,
        errors: result.errors
      })
    }

    process.exit(0)
  } catch (error) {
    logger.error('Weekly review job failed', {}, error as Error)
    process.exit(1)
  }
}

main()
      ]]></code>
    </example>

    <example language="yaml" file="railway.cron.yml">
      <description>Add weekly cron job configuration</description>
      <code><![CDATA[
# Add this entry to existing railway.cron.yml
- name: engagement-weekly
  schedule: "0 9 * * 1"  # Monday 9 AM UTC
  command: "tsx src/cron/run-engagement-weekly.ts"
      ]]></code>
    </example>

    <example language="typescript" file="pt-br.ts">
      <description>Add weekly review celebration message to Portuguese localization</description>
      <code><![CDATA[
// Add to engagement section around line 397
// NOTE: New key structure for Story 5.3 (different from existing engagementWeeklyReviewActive)

engagement: {
  weekly_review: {
    celebration: "ParabÃ©ns! ðŸŽ‰ VocÃª registrou {{count}} transaÃ§Ãµes esta semana. Continue assim!"
  }
}

// Or if using flat structure:
engagementWeeklyReviewCelebration: (count: number) =>
  `ParabÃ©ns! ðŸŽ‰ VocÃª registrou ${count} transaÃ§Ãµes esta semana. Continue assim!`
      ]]></code>
    </example>

    <example language="typescript" file="en.ts">
      <description>Add weekly review celebration message to English localization</description>
      <code><![CDATA[
// Add to engagement section around line 394
engagement: {
  weekly_review: {
    celebration: "Congratulations! ðŸŽ‰ You recorded {{count}} transactions this week. Keep it up!"
  }
}

// Or if using flat structure:
engagementWeeklyReviewCelebration: (count: number) =>
  `Congratulations! ðŸŽ‰ You recorded ${count} transactions this week. Keep it up!`
      ]]></code>
    </example>
  </code-examples>

  <testing-strategy>
    <unit-tests>
      <test id="test-1">
        <description>Active user with 3 transactions receives weekly review</description>
        <setup>Mock getActiveUsersLastWeek() to return 1 user with transactionCount=3</setup>
        <assertions>
          - queueMessage called with correct params
          - messageKey = 'engagement.weekly_review.celebration'
          - messageParams.count = '3'
          - result.succeeded = 1
        </assertions>
      </test>

      <test id="test-2">
        <description>User with bot activity only (no transactions) receives weekly review</description>
        <setup>Mock getActiveUsersLastWeek() to return 1 user with transactionCount=0</setup>
        <assertions>
          - queueMessage called
          - messageParams.count = '0'
        </assertions>
      </test>

      <test id="test-3">
        <description>User with no activity does NOT receive message</description>
        <setup>Mock getActiveUsersLastWeek() to return empty array</setup>
        <assertions>
          - queueMessage NOT called
          - result.processed = 0
        </assertions>
      </test>

      <test id="test-4">
        <description>Same user processed twice in same week = one message (idempotency)</description>
        <setup>
          - First run: queueMessage returns true
          - Second run: queueMessage returns true (duplicate silently ignored by upsert)
        </setup>
        <assertions>
          - Both runs: result.succeeded = 1 (cannot distinguish new vs duplicate)
          - Database: only ONE message exists for user this week
          - AC-5.3.3 satisfied: idempotency prevents duplicate messages
        </assertions>
        <note>
          queueMessage uses upsert with ignoreDuplicates, so duplicate attempts return true.
          Test should verify database state to confirm only one message exists.
        </note>
      </test>

      <test id="test-5">
        <description>Job continues processing after one user fails</description>
        <setup>Mock 3 users, second one throws non-duplicate error</setup>
        <assertions>
          - result.processed = 3
          - result.succeeded = 2
          - result.failed = 1
          - result.errors.length = 1
        </assertions>
      </test>

      <test id="test-6">
        <description>ISO week format consistency</description>
        <setup>Test multiple dates within same week (Mon-Sun)</setup>
        <assertions>
          - All dates generate same idempotency key
          - Format: {userId}:weekly_review:{YYYY}-W{ww}
        </assertions>
      </test>

      <test id="test-7">
        <description>Job result counts are accurate</description>
        <setup>Mock various scenarios</setup>
        <assertions>
          - All counts match expected values
          - durationMs is recorded
        </assertions>
      </test>
    </unit-tests>

    <test-patterns>
      <reference>whatsapp-bot/src/__tests__/scheduler/daily-engagement-job.test.ts</reference>
      <mocking>
        - Mock getActiveUsersLastWeek from activity-detector
        - Mock queueMessage from message-sender
        - Mock PostHog client
        - Mock logger (if needed)
      </mocking>
    </test-patterns>
  </testing-strategy>

  <architecture-decisions>
    <decision id="ADR-001">
      <title>No State Machine Involvement</title>
      <context>Weekly review is celebratory, not a state transition</context>
      <decision>Do NOT use state machine. Directly queue messages via message-sender service.</decision>
      <consequences>Simpler implementation, no coupling to engagement states</consequences>
    </decision>

    <decision id="ADR-002">
      <title>ISO Week Format for Idempotency</title>
      <context>Need consistent week boundaries across different dates</context>
      <decision>Use ISO 8601 week format (YYYY-Www) via date-fns functions</decision>
      <consequences>Weeks always start Monday, end Sunday. Consistent globally.</consequences>
    </decision>

    <decision id="ADR-003">
      <title>Celebratory Message Design</title>
      <context>Weekly review should encourage, not intrude</context>
      <decision>
        - Positive tone with emoji
        - Specific transaction count
        - Brief message
        - Only sent to ACTIVE users (no spam)
      </decision>
      <consequences>Higher engagement, lower opt-out rate</consequences>
    </decision>
  </architecture-decisions>

  <reference-links>
    <link type="story">docs/sprint-artifacts/5-3-weekly-review-job-message.md</link>
    <link type="epic-tech-spec">docs/sprint-artifacts/tech-spec-epic-5.md</link>
    <link type="architecture">docs/architecture.md (FR21, FR22, FR23, FR47)</link>
    <link type="dependency-story">docs/sprint-artifacts/5-2-weekly-activity-detection.md</link>
    <link type="dependency-story">docs/sprint-artifacts/5-1-daily-engagement-job.md</link>
  </reference-links>
</story-context>
